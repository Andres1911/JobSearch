<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/cover_letter_generator_killer_streamlined.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/cover_letter_generator_killer_streamlined.py" />
              <option name="updatedContent" value="from openai import AsyncOpenAI&#10;import json&#10;import time&#10;from datetime import datetime, timedelta&#10;from typing import Dict, List, Optional&#10;from dataclasses import dataclass&#10;from pathlib import Path&#10;import re&#10;from reportlab.lib.pagesizes import letter&#10;from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle&#10;from reportlab.lib.units import inch&#10;from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer&#10;from docx import Document&#10;from docx.enum.text import WD_ALIGN_PARAGRAPH&#10;from personal_context import PERSONAL_CONTEXT, PersonalContext&#10;from prompts_new import COMPANY_RESEARCH_PROMPT, COVER_LETTER_GENERATION_PROMPT_ENGLISH, COVER_LETTER_GENERATION_PROMPT_FRENCH&#10;from shared_utils import FileUtils, StringUtils, CacheUtils, PathUtils&#10;&#10;@dataclass&#10;class JobPosting:&#10;    company_name: str&#10;    job_title: str&#10;    job_description: str&#10;    job_id: str&#10;    link: Optional[str] = None&#10;&#10;class CoverLetterGenerator:&#10;    def __init__(self, openai_api_key: str, personal_context: PersonalContext, config_file=&quot;user_config.json&quot;):&#10;        self.client = AsyncOpenAI(api_key=openai_api_key)&#10;        self.personal_context = personal_context&#10;&#10;        # Load user configuration using shared utility&#10;        self.config = FileUtils.load_json(Path(config_file), {})&#10;&#10;        # Directory paths&#10;        self.job_contents_dir = Path(&quot;./job_contents&quot;)&#10;        self.company_research_cache = Path(&quot;./company_research_cache.json&quot;)&#10;&#10;        # Professional contact information from config&#10;        personal_info = self.config.get('personal_info', {})&#10;        self.contact_info = {&#10;            &quot;name&quot;: personal_info.get('name', 'Your Name'),&#10;            &quot;email&quot;: personal_info.get('email', 'your.email@example.com'),&#10;            &quot;phone&quot;: personal_info.get('phone', '(000) 000-0000'),&#10;            &quot;linkedin&quot;: personal_info.get('linkedin', 'linkedin.com/in/yourprofile')&#10;        }&#10;&#10;    def check_existing_cover_letter(self, company_name: str, job_id: str, job_title: str = None) -&gt; bool:&#10;        &quot;&quot;&quot;Check if a cover letter already exists for this job&quot;&quot;&quot;&#10;        company_folder = self.get_company_folder(company_name)&#10;        &#10;        # Check for position-specific files if job_title is provided&#10;        if job_title:&#10;            safe_title = StringUtils.get_safe_filename(job_title)&#10;            for ext in ['pdf', 'docx']:&#10;                if PathUtils.file_exists(company_folder / f&quot;{safe_title}_cover_letter.{ext}&quot;):&#10;                    return True&#10;&#10;        # Fallback: check for generic files (backward compatibility)&#10;        for ext in ['pdf', 'docx']:&#10;            if PathUtils.file_exists(company_folder / f&quot;cover_letter.{ext}&quot;):&#10;                return True&#10;                &#10;        return False&#10;&#10;    def get_company_folder(self, company_name: str) -&gt; Path:&#10;        &quot;&quot;&quot;Get the company folder path, create if it doesn't exist&quot;&quot;&quot;&#10;        safe_name = StringUtils.get_safe_company_name(company_name)&#10;        return PathUtils.ensure_dir(self.job_contents_dir / safe_name)&#10;&#10;    def save_job_description(self, company_folder: Path, job_posting: JobPosting):&#10;        &quot;&quot;&quot;Save job description to company folder&quot;&quot;&quot;&#10;        safe_title = StringUtils.get_safe_filename(job_posting.job_title)&#10;        job_desc_file = company_folder / f&quot;{safe_title}_job_description.md&quot;&#10;        &#10;        content = f&quot;&quot;&quot;# {job_posting.job_title}&#10;&#10;**Company:** {job_posting.company_name}&#10;**Job ID:** {job_posting.job_id}&#10;{f&quot;**Link:** {job_posting.link}&quot; if job_posting.link else &quot;&quot;}&#10;&#10;## Job Description&#10;&#10;{job_posting.job_description}&quot;&quot;&quot;&#10;        &#10;        FileUtils.save_text(job_desc_file, content)&#10;&#10;    def save_research_results(self, company_folder: Path, company_name: str, research_data: dict):&#10;        &quot;&quot;&quot;Save research results to company folder&quot;&quot;&quot;&#10;        research_file = company_folder / f&quot;Research_{StringUtils.get_safe_company_name(company_name)}.json&quot;&#10;        FileUtils.save_json(research_file, CacheUtils.create_cache_entry(research_data))&#10;&#10;    def load_company_research_cache(self) -&gt; Dict:&#10;        &quot;&quot;&quot;Load cached company research results&quot;&quot;&quot;&#10;        return FileUtils.load_json(self.company_research_cache, {})&#10;&#10;    def save_company_research_cache(self, cache: Dict):&#10;        &quot;&quot;&quot;Save company research results to cache&quot;&quot;&quot;&#10;        try:&#10;            print(f&quot; Saving company research cache to: {self.company_research_cache}&quot;)&#10;            FileUtils.save_json(self.company_research_cache, cache)&#10;            print(f&quot;✅ Successfully saved cache with {len(cache)} companies&quot;)&#10;        except Exception as e:&#10;            print(f&quot;❌ Error saving company research cache: {e}&quot;)&#10;            print(f&quot;   Cache path: {self.company_research_cache}&quot;)&#10;            print(f&quot;   Cache data keys: {list(cache.keys()) if cache else 'None'}&quot;)&#10;            raise&#10;&#10;    def is_research_fresh(self, cached_data: Dict) -&gt; bool:&#10;        &quot;&quot;&quot;Check if cached research is less than 2 years old&quot;&quot;&quot;&#10;        return CacheUtils.is_cache_fresh(cached_data, max_age_days=730)&#10;&#10;    def load_job_description(self, company_name: str, job_title: str, job_id: str) -&gt; Optional[str]:&#10;        &quot;&quot;&quot;Load job description from company folder&quot;&quot;&quot;&#10;        try:&#10;            company_folder = self.get_company_folder(company_name)&#10;            safe_title = StringUtils.get_safe_filename(job_title)&#10;            job_desc_file = company_folder / f&quot;{safe_title}_job_description.md&quot;&#10;&#10;            # Try multiple fallback locations for backward compatibility&#10;            fallback_files = [&#10;                company_folder / f&quot;Job_Description_{job_id}.md&quot;,&#10;                company_folder / &quot;job_description.md&quot;,&#10;                self.job_contents_dir / f&quot;{safe_title}_{job_id}.md&quot;&#10;            ]&#10;&#10;            if not PathUtils.file_exists(job_desc_file):&#10;                for fallback in fallback_files:&#10;                    if PathUtils.file_exists(fallback):&#10;                        # Move old file to new structure if found&#10;                        if fallback == self.job_contents_dir / f&quot;{safe_title}_{job_id}.md&quot;:&#10;                            print(f&quot; Moving job description to new structure: {company_name}&quot;)&#10;                            with open(fallback, 'r', encoding='utf-8') as f:&#10;                                content = f.read()&#10;                            FileUtils.save_text(job_desc_file, content)&#10;                            print(f&quot;✅ Moved: {fallback} -&gt; {job_desc_file}&quot;)&#10;                        else:&#10;                            job_desc_file = fallback&#10;                        break&#10;                else:&#10;                    print(f&quot;⚠️ Job description file not found for {company_name} - {job_title}&quot;)&#10;                    return None&#10;&#10;            with open(job_desc_file, 'r', encoding='utf-8') as f:&#10;                content = f.read()&#10;&#10;            # Extract job description content&#10;            description_match = re.search(r'## Job Description\s*\n\n(.*)', content, re.DOTALL)&#10;            if description_match:&#10;                return description_match.group(1).strip()&#10;&#10;            # Fallback: return content after the first few metadata lines&#10;            lines = content.split('\n')&#10;            for i, line in enumerate(lines):&#10;                if line.startswith('## Job Description') or (i &gt; 5 and line.strip()):&#10;                    return '\n'.join(lines[i+1:]).strip()&#10;            &#10;            return content.strip()&#10;&#10;        except Exception as e:&#10;            print(f&quot;❌ Error loading job description: {e}&quot;)&#10;            return None&#10;&#10;    async def research_company(self, company_name: str) -&gt; Dict:&#10;        &quot;&quot;&quot;Research company with caching to save tokens&quot;&quot;&quot;&#10;        # Load cache&#10;        cache = self.load_company_research_cache()&#10;&#10;        # Check if we have fresh cached data (less than 2 years old)&#10;        if company_name in cache and self.is_research_fresh(cache[company_name]):&#10;            print(f&quot; Using cached research for {company_name} (saves tokens!)&quot;)&#10;            return cache[company_name]['data']&#10;&#10;        print(f&quot; Researching {company_name} (using AI tokens)&quot;)&#10;&#10;        raw_response = &quot;&quot;  # Initialize to avoid reference before assignment warning&#10;        try:&#10;            # Use the imported prompt and format it with the company name&#10;            prompt = COMPANY_RESEARCH_PROMPT.format(company_name=company_name)&#10;&#10;            response = await self.client.chat.completions.create(&#10;                model=&quot;gpt-4o&quot;,&#10;                messages=[{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt}],&#10;                max_tokens=1000&#10;            )&#10;&#10;            raw_response = response.choices[0].message.content&#10;            print(f&quot; Raw AI response length: {len(raw_response)} characters&quot;)&#10;&#10;            # Strip markdown code blocks if present&#10;            json_content = raw_response.strip()&#10;            if json_content.startswith('```json'):&#10;                json_content = json_content[7:]&#10;            if json_content.startswith('```'):&#10;                json_content = json_content[3:]&#10;            if json_content.endswith('```'):&#10;                json_content = json_content[:-3]&#10;            json_content = json_content.strip()&#10;&#10;            research_data = json.loads(json_content)&#10;            print(f&quot;✅ Successfully parsed JSON research data&quot;)&#10;&#10;            # Cache the results with timestamp&#10;            cache[company_name] = {&#10;                'data': research_data,&#10;                'timestamp': datetime.now().isoformat()&#10;            }&#10;            self.save_company_research_cache(cache)&#10;&#10;            # Also save to company folder&#10;            company_folder = self.get_company_folder(company_name)&#10;            self.save_research_results(company_folder, company_name, research_data)&#10;&#10;            return research_data&#10;&#10;        except json.JSONDecodeError as e:&#10;            print(f&quot;❌ JSON parsing failed: {e}&quot;)&#10;            print(f&quot;❌ Raw response that failed to parse: {raw_response}&quot;)&#10;            return {&quot;error&quot;: &quot;Failed to parse company research&quot;}&#10;        except Exception as e:&#10;            print(f&quot;❌ Error researching {company_name}: {e}&quot;)&#10;            return {&quot;error&quot;: f&quot;Research failed: {str(e)}&quot;}&#10;&#10;    def detect_language(self, text: str) -&gt; str:&#10;        &quot;&quot;&quot;Detect if text is primarily French or English&quot;&quot;&quot;&#10;        return StringUtils.detect_language(text)&#10;&#10;    def create_killer_cover_letter_prompt(self, job_posting: JobPosting, company_info: Dict) -&gt; str:&#10;        &quot;&quot;&quot;Create the prompt for generating a killer cover letter&quot;&quot;&quot;&#10;        # Detect language of job description&#10;        language = self.detect_language(job_posting.job_description)&#10;&#10;        # Choose appropriate prompt&#10;        if language == &quot;french&quot;:&#10;            prompt_template = COVER_LETTER_GENERATION_PROMPT_FRENCH&#10;            print(f&quot; Detected French job description, using French prompt&quot;)&#10;        else:&#10;            prompt_template = COVER_LETTER_GENERATION_PROMPT_ENGLISH&#10;            print(f&quot; Detected English job description, using English prompt&quot;)&#10;&#10;        # Format personal context&#10;        personal_context_text = f&quot;&quot;&quot;&#10;RESUME: {self.personal_context.resume}&#10;&#10;SKILLS: {', '.join(self.personal_context.skills)}&#10;&#10;ACHIEVEMENTS: {', '.join(self.personal_context.achievements)}&#10;&#10;PERSONAL VALUES: {', '.join(self.personal_context.personal_values)}&#10;&#10;ADDITIONAL INFO: {self.personal_context.additional_info}&#10;&#10;CONSTRAINTS: {self.personal_context.constraints}&#10;        &quot;&quot;&quot;.strip()&#10;&#10;        # Format company research&#10;        company_research_text = json.dumps(company_info, indent=2) if company_info else &quot;No research data available&quot;&#10;&#10;        return prompt_template.format(&#10;            personal_context=personal_context_text,&#10;            company_name=job_posting.company_name,&#10;            job_title=job_posting.job_title,&#10;            job_description=job_posting.job_description,&#10;            company_research=company_research_text,&#10;            user_name=self.contact_info['name']&#10;        )&#10;&#10;    def _format_date_by_language(self, language: str) -&gt; str:&#10;        &quot;&quot;&quot;Format date according to language&quot;&quot;&quot;&#10;        if language == &quot;french&quot;:&#10;            import locale&#10;            try:&#10;                locale.setlocale(locale.LC_TIME, 'fr_FR.UTF-8')&#10;                return time.strftime('%d %B %Y')&#10;            except locale.Error:&#10;                # Fallback if French locale not available&#10;                months_fr = {&#10;                    'January': 'janvier', 'February': 'février', 'March': 'mars', 'April': 'avril',&#10;                    'May': 'mai', 'June': 'juin', 'July': 'juillet', 'August': 'août',&#10;                    'September': 'septembre', 'October': 'octobre', 'November': 'novembre', 'December': 'décembre'&#10;                }&#10;                date_en = time.strftime('%d %B %Y')&#10;                for en, fr in months_fr.items():&#10;                    date_en = date_en.replace(en, fr)&#10;                return date_en&#10;        else:&#10;            return time.strftime('%B %d, %Y')&#10;&#10;    def create_pdf_cover_letter(self, content: str, job_posting: JobPosting, filepath: Path):&#10;        &quot;&quot;&quot;Generate a professional PDF cover letter&quot;&quot;&quot;&#10;        # Detect language for proper formatting&#10;        language = self.detect_language(job_posting.job_description)&#10;        hiring_manager_text = &quot;Responsable du recrutement&quot; if language == &quot;french&quot; else &quot;Hiring Manager&quot;&#10;        date_formatted = self._format_date_by_language(language)&#10;&#10;        doc = SimpleDocTemplate(str(filepath), pagesize=letter, topMargin=0.5*inch)&#10;        styles = getSampleStyleSheet()&#10;&#10;        # Custom styles with better spacing&#10;        header_style = ParagraphStyle(&#10;            'CustomHeader',&#10;            parent=styles['Normal'],&#10;            fontSize=11,&#10;            alignment=2,  # Right align&#10;            spaceAfter=20&#10;        )&#10;&#10;        body_style = ParagraphStyle(&#10;            'CustomBody',&#10;            parent=styles['Normal'],&#10;            fontSize=11,&#10;            alignment=0,  # Left align&#10;            spaceAfter=14,&#10;            leftIndent=0,&#10;            rightIndent=0,&#10;            leading=14&#10;        )&#10;&#10;        story = []&#10;&#10;        # Header with contact info - make email and LinkedIn clickable and underlined&#10;        header_text = f&quot;&quot;&quot;&#10;        &lt;b&gt;{self.contact_info['name']}&lt;/b&gt;&lt;br/&gt;&#10;        &lt;a href=&quot;mailto:{self.contact_info['email']}&quot; color=&quot;blue&quot;&gt;&lt;u&gt;{self.contact_info['email']}&lt;/u&gt;&lt;/a&gt;&lt;br/&gt;&#10;        {self.contact_info['phone']}&lt;br/&gt;&#10;        &lt;a href=&quot;https://{self.contact_info['linkedin']}&quot; color=&quot;blue&quot;&gt;&lt;u&gt;{self.contact_info['linkedin']}&lt;/u&gt;&lt;/a&gt;&#10;        &quot;&quot;&quot;&#10;        story.append(Paragraph(header_text, header_style))&#10;        story.append(Spacer(1, 20))&#10;&#10;        # Date and company info&#10;        date_text = f&quot;&quot;&quot;&#10;        {date_formatted}&lt;br/&gt;&lt;br/&gt;&#10;        &lt;b&gt;{job_posting.company_name}&lt;/b&gt;&lt;br/&gt;&#10;        {hiring_manager_text}&lt;br/&gt;&#10;        Re: {job_posting.job_title}&#10;        &quot;&quot;&quot;&#10;        story.append(Paragraph(date_text, body_style))&#10;        story.append(Spacer(1, 20))&#10;&#10;        # Cover letter content with proper paragraph spacing&#10;        paragraphs = content.split('\n')&#10;        for para in paragraphs:&#10;            if para.strip():&#10;                formatted_para = re.sub(r'\*\*(.*?)\*\*', r'&lt;b&gt;\1&lt;/b&gt;', para.strip())&#10;                story.append(Paragraph(formatted_para, body_style))&#10;&#10;        doc.build(story)&#10;&#10;    def create_docx_cover_letter(self, content: str, job_posting: JobPosting, filepath: Path):&#10;        &quot;&quot;&quot;Generate a professional Word document cover letter&quot;&quot;&quot;&#10;        # Detect language for proper formatting&#10;        language = self.detect_language(job_posting.job_description)&#10;        hiring_manager_text = &quot;Responsable du recrutement&quot; if language == &quot;french&quot; else &quot;Hiring Manager&quot;&#10;        date_formatted = self._format_date_by_language(language)&#10;&#10;        doc = Document()&#10;&#10;        # Header with contact info - right aligned&#10;        header_para = doc.add_paragraph()&#10;        header_para.alignment = WD_ALIGN_PARAGRAPH.RIGHT&#10;&#10;        # Add name (bold)&#10;        name_run = header_para.add_run(f&quot;{self.contact_info['name']}\n&quot;)&#10;        name_run.bold = True&#10;&#10;        # Add email (as plain text since python-docx hyperlinks are complex)&#10;        header_para.add_run(f&quot;{self.contact_info['email']}\n&quot;)&#10;&#10;        # Add phone&#10;        header_para.add_run(f&quot;{self.contact_info['phone']}\n&quot;)&#10;&#10;        # Add LinkedIn&#10;        header_para.add_run(f&quot;{self.contact_info['linkedin']}&quot;)&#10;&#10;        # Add space&#10;        doc.add_paragraph()&#10;&#10;        # Date and company info&#10;        date_para = doc.add_paragraph()&#10;        date_para.add_run(f&quot;{date_formatted}\n\n&quot;)&#10;&#10;        company_run = date_para.add_run(f&quot;{job_posting.company_name}\n&quot;)&#10;        company_run.bold = True&#10;        date_para.add_run(f&quot;{hiring_manager_text}\n&quot;)&#10;        date_para.add_run(f&quot;Re: {job_posting.job_title}\n&quot;)&#10;&#10;        # Add space&#10;        doc.add_paragraph()&#10;&#10;        # Cover letter content - single line breaks&#10;        paragraphs = content.split('\n')&#10;        for para in paragraphs:&#10;            if para.strip():&#10;                doc.add_paragraph(para.strip())&#10;&#10;        doc.save(str(filepath))&#10;&#10;    async def generate_cover_letter(self, job_posting: JobPosting) -&gt; Dict:&#10;        try:&#10;            print(f&quot; Generating killer cover letter for: {job_posting.job_title} at {job_posting.company_name}&quot;)&#10;&#10;            # Step 1: Research company thoroughly (with caching!)&#10;            company_info = await self.research_company(job_posting.company_name)&#10;&#10;            # Step 2: Create killer cover letter using proven formula&#10;            prompt = self.create_killer_cover_letter_prompt(job_posting, company_info)&#10;&#10;            response = await self.client.chat.completions.create(&#10;                model=&quot;gpt-4o&quot;,&#10;                messages=[{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt}],&#10;                max_tokens=1200,&#10;                temperature=0.7&#10;            )&#10;&#10;            cover_letter = response.choices[0].message.content&#10;&#10;            # Step 3: Save with position-specific filenames&#10;            company_folder = self.get_company_folder(job_posting.company_name)&#10;            safe_title = StringUtils.get_safe_filename(job_posting.job_title)&#10;&#10;            # PDF version (most professional) - save with job title&#10;            pdf_filepath = company_folder / f&quot;{safe_title}_cover_letter.pdf&quot;&#10;            self.create_pdf_cover_letter(cover_letter, job_posting, pdf_filepath)&#10;&#10;            # Word version (for easy editing) - save with job title&#10;            docx_filepath = company_folder / f&quot;{safe_title}_cover_letter.docx&quot;&#10;            self.create_docx_cover_letter(cover_letter, job_posting, docx_filepath)&#10;&#10;            # Also save job description&#10;            self.save_job_description(company_folder, job_posting)&#10;&#10;            # Fixed: Avoid nested f-strings by using separate variables&#10;            research_filename = f'Research_{StringUtils.get_safe_company_name(job_posting.company_name)}.json'&#10;            job_desc_filename = f'{safe_title}_job_description.md'&#10;            &#10;            print(f&quot;✅ Cover letter saved for specific position:&quot;)&#10;            print(f&quot;    Company folder: {company_folder}&quot;)&#10;            print(f&quot;    PDF: {pdf_filepath}&quot;)&#10;            print(f&quot;    Word: {docx_filepath}&quot;)&#10;            print(f&quot;    Research: {company_folder / research_filename}&quot;)&#10;            print(f&quot;    Job desc: {company_folder / job_desc_filename}&quot;)&#10;&#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;cover_letter&quot;: cover_letter,&#10;                &quot;pdf_filepath&quot;: str(pdf_filepath),&#10;                &quot;docx_filepath&quot;: str(docx_filepath),&#10;                &quot;company_folder&quot;: str(company_folder),&#10;                &quot;company_info&quot;: company_info,&#10;                &quot;job_id&quot;: job_posting.job_id&#10;            }&#10;&#10;        except Exception as e:&#10;            print(f&quot;❌ Error generating cover letter for {job_posting.job_title}: {e}&quot;)&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;error&quot;: str(e),&#10;                &quot;job_id&quot;: job_posting.job_id,&#10;                &quot;company&quot;: job_posting.company_name,&#10;                &quot;title&quot;: job_posting.job_title&#10;            }&#10;&#10;    async def process_job_batch(self, job_postings: List[JobPosting], delay: int = 2) -&gt; List[Dict]:&#10;        results = []&#10;        print(f&quot; Starting batch processing for {len(job_postings)} jobs...&quot;)&#10;&#10;        for i, job_posting in enumerate(job_postings):&#10;            print(f&quot;\n Processing {i+1}/{len(job_postings)}: {job_posting.company_name} - {job_posting.job_title}&quot;)&#10;&#10;            result = await self.generate_cover_letter(job_posting)&#10;            results.append(result)&#10;&#10;            if i &lt; len(job_postings) - 1:&#10;                print(f&quot;⏳ Waiting {delay} seconds...&quot;)&#10;                time.sleep(delay)&#10;&#10;        return results&#10;&#10;    @classmethod&#10;    def load_jobs_from_processed_file(cls, processed_jobs_file: str = &quot;processed_jobs.json&quot;) -&gt; List[JobPosting]:&#10;        job_postings = []&#10;&#10;        try:&#10;            with open(processed_jobs_file, 'r', encoding='utf-8') as f:&#10;                processed_jobs = json.load(f)&#10;&#10;            print(f&quot; Loading {len(processed_jobs)} jobs from {processed_jobs_file}&quot;)&#10;&#10;            # Use a dummy PersonalContext for loading job descriptions only&#10;            generator_temp = cls(&quot;dummy_key&quot;, PERSONAL_CONTEXT)&#10;&#10;            for job_id, job_info in processed_jobs.items():&#10;                job_description = generator_temp.load_job_description(job_info[&quot;company&quot;], job_info[&quot;job_title&quot;], job_id)&#10;&#10;                if job_description:&#10;                    job_posting = JobPosting(&#10;                        company_name=job_info[&quot;company&quot;],&#10;                        job_title=job_info[&quot;job_title&quot;],&#10;                        job_description=job_description,&#10;                        job_id=job_id,&#10;                        link=job_info.get(&quot;link&quot;)&#10;                    )&#10;                    job_postings.append(job_posting)&#10;                    print(f&quot;✅ Loaded: {job_info['job_title']} at {job_info['company']}&quot;)&#10;                else:&#10;                    print(f&quot;⚠️ Skipped: {job_info['job_title']} at {job_info['company']}&quot;)&#10;&#10;            print(f&quot;✅ Successfully loaded {len(job_postings)} jobs with descriptions&quot;)&#10;            return job_postings&#10;&#10;        except FileNotFoundError:&#10;            print(f&quot;❌ File {processed_jobs_file} not found&quot;)&#10;            return []&#10;        except json.JSONDecodeError as e:&#10;            print(f&quot;❌ Error parsing {processed_jobs_file}: {e}&quot;)&#10;            return []&#10;        except Exception as e:&#10;            print(f&quot;❌ Error loading jobs: {e}&quot;)&#10;            return []" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/cover_letter_generator_v2.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/cover_letter_generator_v2.py" />
              <option name="originalContent" value="import openai&#10;from openai import AsyncOpenAI&#10;import json&#10;import time&#10;from typing import Dict, List, Optional&#10;from dataclasses import dataclass&#10;from pathlib import Path&#10;import os&#10;import re&#10;&#10;@dataclass&#10;class JobPosting:&#10;    company_name: str&#10;    job_title: str&#10;    job_description: str&#10;    job_id: str&#10;    link: Optional[str] = None&#10;&#10;@dataclass&#10;class PersonalContext:&#10;    resume: str&#10;    sample_cover_letter: str&#10;    additional_info: str&#10;    skills: List[str]&#10;    achievements: List[str]&#10;    constraints: str&#10;&#10;class CoverLetterGenerator:&#10;    def __init__(self, openai_api_key: str, personal_context: PersonalContext):&#10;        self.client = AsyncOpenAI(api_key=openai_api_key)&#10;        self.personal_context = personal_context&#10;        self.output_dir = Path(&quot;generated_cover_letters&quot;)&#10;        self.output_dir.mkdir(exist_ok=True)&#10;        self.job_contents_dir = Path(&quot;./job_contents&quot;)&#10;&#10;    def load_job_description(self, job_title: str, job_id: str) -&gt; Optional[str]:&#10;        &quot;&quot;&quot;Load job description from markdown file in job_contents directory&quot;&quot;&quot;&#10;        try:&#10;            # Create safe filename (same logic as in linkedin_bot.py)&#10;            safe_filename = &quot;&quot;.join(c for c in job_title if c.isalnum() or c in (' ', '-', '_')).rstrip()&#10;            filename = f&quot;{safe_filename}_{job_id}.md&quot;&#10;            filepath = self.job_contents_dir / filename&#10;&#10;            if filepath.exists():&#10;                with open(filepath, 'r', encoding='utf-8') as f:&#10;                    content = f.read()&#10;&#10;                # Extract just the job description part (after &quot;## Job Description&quot;)&#10;                description_match = re.search(r'## Job Description\s*\n\n(.*)', content, re.DOTALL)&#10;                if description_match:&#10;                    return description_match.group(1).strip()&#10;                else:&#10;                    # Fallback: return everything after the header section&#10;                    lines = content.split('\n')&#10;                    description_lines = []&#10;                    found_description = False&#10;&#10;                    for line in lines:&#10;                        if '---' in line:&#10;                            found_description = True&#10;                            continue&#10;                        if found_description:&#10;                            description_lines.append(line)&#10;&#10;                    return '\n'.join(description_lines).strip()&#10;            else:&#10;                print(f&quot;⚠️ Job description file not found: {filepath}&quot;)&#10;                return None&#10;&#10;        except Exception as e:&#10;            print(f&quot;❌ Error loading job description for {job_title} ({job_id}): {e}&quot;)&#10;            return None&#10;&#10;    async def research_company(self, company_name: str, company_url: Optional[str] = None) -&gt; Dict:&#10;        &quot;&quot;&quot;Research company using OpenAI API&quot;&quot;&quot;&#10;        prompt = f&quot;&quot;&quot;&#10;        Research the company &quot;{company_name}&quot; and provide:&#10;        1. Company mission and values&#10;        2. Recent news or achievements (last 6 months)&#10;        3. Company culture highlights&#10;        4. Key products/services&#10;        &#10;        Format as JSON with keys: mission, recent_news, culture, products&#10;        &quot;&quot;&quot;&#10;&#10;        response = await self.client.chat.completions.create(&#10;            model=&quot;gpt-4o&quot;,&#10;            messages=[{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt}],&#10;            max_tokens=800&#10;        )&#10;&#10;        try:&#10;            return json.loads(response.choices[0].message.content)&#10;        except json.JSONDecodeError:&#10;            return {&quot;error&quot;: &quot;Failed to parse company research&quot;}&#10;&#10;    def create_cover_letter_prompt(self, job_posting: JobPosting, company_info: Dict) -&gt; str:&#10;        &quot;&quot;&quot;Create detailed prompt for cover letter generation - IMPROVED VERSION&quot;&quot;&quot;&#10;        return f&quot;&quot;&quot;&#10;        Write a personalized cover letter for this job application. Make it sound like a real person wrote it - warm, genuine, and conversational.&#10;&#10;        JOB DETAILS:&#10;        Company: {job_posting.company_name}&#10;        Position: {job_posting.job_title}&#10;        Job Description: {job_posting.job_description}&#10;        &#10;        COMPANY RESEARCH:&#10;        Mission: {company_info.get('mission', 'N/A')}&#10;        Recent News: {company_info.get('recent_news', 'N/A')}&#10;        Culture: {company_info.get('culture', 'N/A')}&#10;        Products: {company_info.get('products', 'N/A')}&#10;        &#10;        CANDIDATE BACKGROUND:&#10;        {self.personal_context.resume}&#10;        &#10;        WRITING STYLE REFERENCE (match this tone):&#10;        {self.personal_context.sample_cover_letter}&#10;        &#10;        ADDITIONAL CONTEXT:&#10;        {self.personal_context.additional_info}&#10;        &#10;        WRITING RULES:&#10;        1. Sound like a real McGill student, not a corporate robot&#10;        2. Be conversational and genuine - like you're talking to a friend about why you want this job&#10;        3. Don't mention the job ID number - that's weird&#10;        4. Pick 2-3 relevant projects/skills that actually connect to this specific role&#10;        5. Show you've done research on the company, but don't list everything&#10;        6. End with &quot;Best regards, Andres Gonzalez&quot; (not &quot;[Your Name]&quot;)&#10;        7. Keep it under 350 words&#10;        8. Make each paragraph flow logically to the next&#10;        &#10;        BANNED PHRASES (do not use these):&#10;        - &quot;I am writing to express my interest&quot;&#10;        - &quot;I am drawn to&quot;&#10;        - &quot;innovative solutions&quot; &#10;        - &quot;cutting-edge&quot;&#10;        - &quot;make a meaningful impact&quot;&#10;        - &quot;tackle complex challenges&quot;&#10;        - &quot;I look forward to the opportunity&quot;&#10;        - &quot;shaping a better world&quot;&#10;        - &quot;aligns well with&quot;&#10;        - &quot;resonates with my interest&quot;&#10;        - &quot;I am enthusiastic about&quot;&#10;        - &quot;I am keen to&quot;&#10;        - Any phrase that sounds like corporate marketing&#10;        &#10;        TONE: Professional but human. Like you're genuinely interested in this specific company and role, not just applying everywhere. Show personality while staying professional.&#10;        &#10;        STRUCTURE:&#10;        1. Brief, natural opening - why this specific role interests you&#10;        2. 1-2 relevant projects that connect to the job requirements&#10;        3. What you know about the company that genuinely interests you&#10;        4. Simple, confident closing&#10;        &#10;        EXAMPLES OF GOOD OPENINGS:&#10;        - &quot;Hey [Company] team, I saw your [role] posting and...&quot;&#10;        - &quot;I've been following [Company]'s work on [specific project] and...&quot;&#10;        - &quot;As someone who's built [relevant project], I'm really interested in...&quot;&#10;        &#10;        Write the cover letter now:&#10;        &quot;&quot;&quot;&#10;&#10;    async def generate_cover_letter(self, job_posting: JobPosting) -&gt; Dict:&#10;        &quot;&quot;&quot;Generate cover letter for a job posting&quot;&quot;&quot;&#10;        try:&#10;            print(f&quot; Generating cover letter for: {job_posting.job_title} at {job_posting.company_name}&quot;)&#10;&#10;            # Step 1: Research company&#10;            company_info = await self.research_company(job_posting.company_name)&#10;&#10;            # Step 2: Create prompt&#10;            prompt = self.create_cover_letter_prompt(job_posting, company_info)&#10;&#10;            # Step 3: Generate cover letter&#10;            response = await self.client.chat.completions.create(&#10;                model=&quot;gpt-4o&quot;,&#10;                messages=[{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt}],&#10;                max_tokens=1000,&#10;                temperature=0.7&#10;            )&#10;&#10;            cover_letter = response.choices[0].message.content&#10;&#10;            # Step 4: Save cover letter&#10;            safe_company = &quot;&quot;.join(c for c in job_posting.company_name if c.isalnum() or c in (' ', '-', '_')).strip()&#10;            safe_title = &quot;&quot;.join(c for c in job_posting.job_title if c.isalnum() or c in (' ', '-', '_')).strip()&#10;            filename = f&quot;{safe_company}_{safe_title}_{job_posting.job_id}&quot;&#10;            filepath = self.output_dir / f&quot;{filename}_cover_letter_v2.txt&quot;&#10;&#10;            with open(filepath, 'w', encoding='utf-8') as f:&#10;                f.write(f&quot;Company: {job_posting.company_name}\n&quot;)&#10;                f.write(f&quot;Position: {job_posting.job_title}\n&quot;)&#10;                f.write(f&quot;Job ID: {job_posting.job_id}\n&quot;)&#10;                f.write(f&quot;Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}\n&quot;)&#10;                f.write(f&quot;Link: {job_posting.link}\n&quot;)&#10;                f.write(&quot;-&quot; * 50 + &quot;\n\n&quot;)&#10;                f.write(cover_letter)&#10;&#10;            print(f&quot;✅ Cover letter saved: {filepath}&quot;)&#10;&#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;cover_letter&quot;: cover_letter,&#10;                &quot;filepath&quot;: str(filepath),&#10;                &quot;company_info&quot;: company_info,&#10;                &quot;job_id&quot;: job_posting.job_id&#10;            }&#10;&#10;        except Exception as e:&#10;            print(f&quot;❌ Error generating cover letter for {job_posting.job_title}: {e}&quot;)&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;error&quot;: str(e),&#10;                &quot;job_id&quot;: job_posting.job_id,&#10;                &quot;company&quot;: job_posting.company_name,&#10;                &quot;title&quot;: job_posting.job_title&#10;            }&#10;&#10;    async def process_job_batch(self, job_postings: List[JobPosting], delay: int = 2) -&gt; List[Dict]:&#10;        &quot;&quot;&quot;Process multiple job postings with rate limiting&quot;&quot;&quot;&#10;        results = []&#10;&#10;        print(f&quot; Starting batch processing for {len(job_postings)} jobs...&quot;)&#10;&#10;        for i, job_posting in enumerate(job_postings):&#10;            print(f&quot;\n Processing {i+1}/{len(job_postings)}: {job_posting.company_name} - {job_posting.job_title}&quot;)&#10;&#10;            result = await self.generate_cover_letter(job_posting)&#10;            results.append(result)&#10;&#10;            # Rate limiting&#10;            if i &lt; len(job_postings) - 1:&#10;                print(f&quot;⏳ Waiting {delay} seconds before next job...&quot;)&#10;                time.sleep(delay)&#10;&#10;        return results&#10;&#10;    @classmethod&#10;    def load_jobs_from_processed_file(cls, processed_jobs_file: str = &quot;processed_jobs.json&quot;) -&gt; List[JobPosting]:&#10;        &quot;&quot;&quot;Load jobs from your processed_jobs.json file and read descriptions from job_contents&quot;&quot;&quot;&#10;        job_postings = []&#10;&#10;        try:&#10;            with open(processed_jobs_file, 'r', encoding='utf-8') as f:&#10;                processed_jobs = json.load(f)&#10;&#10;            print(f&quot; Loading {len(processed_jobs)} jobs from {processed_jobs_file}&quot;)&#10;&#10;            generator_temp = cls(&quot;dummy_key&quot;, None)  # Temporary instance just for loading descriptions&#10;&#10;            for job_id, job_info in processed_jobs.items():&#10;                # Load job description from markdown file&#10;                job_description = generator_temp.load_job_description(job_info[&quot;job_title&quot;], job_id)&#10;&#10;                if job_description:&#10;                    job_posting = JobPosting(&#10;                        company_name=job_info[&quot;company&quot;],&#10;                        job_title=job_info[&quot;job_title&quot;],&#10;                        job_description=job_description,&#10;                        job_id=job_id,&#10;                        link=job_info.get(&quot;link&quot;)&#10;                    )&#10;                    job_postings.append(job_posting)&#10;                    print(f&quot;✅ Loaded: {job_info['job_title']} at {job_info['company']}&quot;)&#10;                else:&#10;                    print(f&quot;⚠️ Skipped (no description): {job_info['job_title']} at {job_info['company']}&quot;)&#10;&#10;            print(f&quot;✅ Successfully loaded {len(job_postings)} jobs with descriptions&quot;)&#10;            return job_postings&#10;&#10;        except Exception as e:&#10;            print(f&quot;❌ Error loading jobs from {processed_jobs_file}: {e}&quot;)&#10;            return []&#10;" />
              <option name="updatedContent" value="import openai&#10;from openai import AsyncOpenAI&#10;import json&#10;import time&#10;from typing import Dict, List, Optional&#10;from dataclasses import dataclass&#10;from pathlib import Path&#10;import os&#10;import re&#10;&#10;@dataclass&#10;class JobPosting:&#10;    company_name: str&#10;    job_title: str&#10;    job_description: str&#10;    job_id: str&#10;    link: Optional[str] = None&#10;&#10;@dataclass&#10;class PersonalContext:&#10;    resume: str&#10;    sample_cover_letter: str&#10;    additional_info: str&#10;    skills: List[str]&#10;    achievements: List[str]&#10;    constraints: str&#10;&#10;class CoverLetterGenerator:&#10;    def __init__(self, openai_api_key: str, personal_context: PersonalContext):&#10;        self.client = AsyncOpenAI(api_key=openai_api_key)&#10;        self.personal_context = personal_context&#10;        self.output_dir = Path(&quot;generated_cover_letters&quot;)&#10;        self.output_dir.mkdir(exist_ok=True)&#10;        self.job_contents_dir = Path(&quot;./job_contents&quot;)&#10;&#10;    def load_job_description(self, job_title: str, job_id: str) -&gt; Optional[str]:&#10;        &quot;&quot;&quot;Load job description from markdown file in job_contents directory&quot;&quot;&quot;&#10;        try:&#10;            # Create safe filename (same logic as in linkedin_bot.py)&#10;            safe_filename = &quot;&quot;.join(c for c in job_title if c.isalnum() or c in (' ', '-', '_')).rstrip()&#10;            filename = f&quot;{safe_filename}_{job_id}.md&quot;&#10;            filepath = self.job_contents_dir / filename&#10;&#10;            if filepath.exists():&#10;                with open(filepath, 'r', encoding='utf-8') as f:&#10;                    content = f.read()&#10;&#10;                # Extract just the job description part (after &quot;## Job Description&quot;)&#10;                description_match = re.search(r'## Job Description\s*\n\n(.*)', content, re.DOTALL)&#10;                if description_match:&#10;                    return description_match.group(1).strip()&#10;                else:&#10;                    # Fallback: return everything after the header section&#10;                    lines = content.split('\n')&#10;                    description_lines = []&#10;                    found_description = False&#10;&#10;                    for line in lines:&#10;                        if '---' in line:&#10;                            found_description = True&#10;                            continue&#10;                        if found_description:&#10;                            description_lines.append(line)&#10;&#10;                    return '\n'.join(description_lines).strip()&#10;            else:&#10;                print(f&quot;⚠️ Job description file not found: {filepath}&quot;)&#10;                return None&#10;&#10;        except Exception as e:&#10;            print(f&quot;❌ Error loading job description for {job_title} ({job_id}): {e}&quot;)&#10;            return None&#10;&#10;    async def research_company(self, company_name: str, company_url: Optional[str] = None) -&gt; Dict:&#10;        &quot;&quot;&quot;Research company using OpenAI API&quot;&quot;&quot;&#10;        prompt = f&quot;&quot;&quot;&#10;        Research the company &quot;{company_name}&quot; and provide:&#10;        1. Company mission and values&#10;        2. Recent news or achievements (last 6 months)&#10;        3. Company culture highlights&#10;        4. Key products/services&#10;        &#10;        Format as JSON with keys: mission, recent_news, culture, products&#10;        &quot;&quot;&quot;&#10;&#10;        response = await self.client.chat.completions.create(&#10;            model=&quot;gpt-4o&quot;,&#10;            messages=[{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt}],&#10;            max_tokens=800&#10;        )&#10;&#10;        try:&#10;            return json.loads(response.choices[0].message.content)&#10;        except json.JSONDecodeError:&#10;            return {&quot;error&quot;: &quot;Failed to parse company research&quot;}&#10;&#10;    def create_cover_letter_prompt(self, job_posting: JobPosting, company_info: Dict) -&gt; str:&#10;        &quot;&quot;&quot;Create detailed prompt for cover letter generation - IMPROVED VERSION&quot;&quot;&quot;&#10;        return f&quot;&quot;&quot;&#10;        Write a personalized cover letter for this job application. Make it sound like a real person wrote it - warm, genuine, and conversational.&#10;&#10;        JOB DETAILS:&#10;        Company: {job_posting.company_name}&#10;        Position: {job_posting.job_title}&#10;        Job Description: {job_posting.job_description}&#10;        &#10;        COMPANY RESEARCH:&#10;        Mission: {company_info.get('mission', 'N/A')}&#10;        Recent News: {company_info.get('recent_news', 'N/A')}&#10;        Culture: {company_info.get('culture', 'N/A')}&#10;        Products: {company_info.get('products', 'N/A')}&#10;        &#10;        CANDIDATE BACKGROUND:&#10;        {self.personal_context.resume}&#10;        &#10;        WRITING STYLE REFERENCE (match this tone):&#10;        {self.personal_context.sample_cover_letter}&#10;        &#10;        ADDITIONAL CONTEXT:&#10;        {self.personal_context.additional_info}&#10;        &#10;        WRITING RULES:&#10;        1. Sound like a real McGill student, not a corporate robot&#10;        2. Be conversational and genuine - like you're talking to a friend about why you want this job&#10;        3. Don't mention the job ID number - that's weird&#10;        4. Pick 2-3 relevant projects/skills that actually connect to this specific role&#10;        5. Show you've done research on the company, but don't list everything&#10;        6. End with &quot;Best regards, Andres Gonzalez&quot; (not &quot;[Your Name]&quot;)&#10;        7. Keep it under 350 words&#10;        8. Make each paragraph flow logically to the next&#10;        &#10;        BANNED PHRASES (do not use these):&#10;        - &quot;I am writing to express my interest&quot;&#10;        - &quot;I am drawn to&quot;&#10;        - &quot;innovative solutions&quot; &#10;        - &quot;cutting-edge&quot;&#10;        - &quot;make a meaningful impact&quot;&#10;        - &quot;tackle complex challenges&quot;&#10;        - &quot;I look forward to the opportunity&quot;&#10;        - &quot;shaping a better world&quot;&#10;        - &quot;aligns well with&quot;&#10;        - &quot;resonates with my interest&quot;&#10;        - &quot;I am enthusiastic about&quot;&#10;        - &quot;I am keen to&quot;&#10;        - Any phrase that sounds like corporate marketing&#10;        &#10;        TONE: Professional but human. Like you're genuinely interested in this specific company and role, not just applying everywhere. Show personality while staying professional.&#10;        &#10;        STRUCTURE:&#10;        1. Brief, natural opening - why this specific role interests you&#10;        2. 1-2 relevant projects that connect to the job requirements&#10;        3. What you know about the company that genuinely interests you&#10;        4. Simple, confident closing&#10;        &#10;        EXAMPLES OF GOOD OPENINGS:&#10;        - &quot;I'm interested in the [role] position at [Company] because...&quot;&#10;        - &quot;I've been following [Company]'s work on [specific project], and I'm excited about...&quot;&#10;        - &quot;As someone who's built [relevant project], the [role] role at [Company] caught my attention because...&quot;&#10;        - &quot;When I saw [Company]'s [role] posting, it immediately stood out because...&quot;&#10;        &#10;        Write the cover letter now:&#10;        &quot;&quot;&quot;&#10;&#10;    async def generate_cover_letter(self, job_posting: JobPosting) -&gt; Dict:&#10;        &quot;&quot;&quot;Generate cover letter for a job posting&quot;&quot;&quot;&#10;        try:&#10;            print(f&quot; Generating cover letter for: {job_posting.job_title} at {job_posting.company_name}&quot;)&#10;&#10;            # Step 1: Research company&#10;            company_info = await self.research_company(job_posting.company_name)&#10;&#10;            # Step 2: Create prompt&#10;            prompt = self.create_cover_letter_prompt(job_posting, company_info)&#10;&#10;            # Step 3: Generate cover letter&#10;            response = await self.client.chat.completions.create(&#10;                model=&quot;gpt-4o&quot;,&#10;                messages=[{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt}],&#10;                max_tokens=1000,&#10;                temperature=0.7&#10;            )&#10;&#10;            cover_letter = response.choices[0].message.content&#10;&#10;            # Step 4: Save cover letter&#10;            safe_company = &quot;&quot;.join(c for c in job_posting.company_name if c.isalnum() or c in (' ', '-', '_')).strip()&#10;            safe_title = &quot;&quot;.join(c for c in job_posting.job_title if c.isalnum() or c in (' ', '-', '_')).strip()&#10;            filename = f&quot;{safe_company}_{safe_title}_{job_posting.job_id}&quot;&#10;            filepath = self.output_dir / f&quot;{filename}_cover_letter_v2.txt&quot;&#10;&#10;            with open(filepath, 'w', encoding='utf-8') as f:&#10;                f.write(f&quot;Company: {job_posting.company_name}\n&quot;)&#10;                f.write(f&quot;Position: {job_posting.job_title}\n&quot;)&#10;                f.write(f&quot;Job ID: {job_posting.job_id}\n&quot;)&#10;                f.write(f&quot;Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}\n&quot;)&#10;                f.write(f&quot;Link: {job_posting.link}\n&quot;)&#10;                f.write(&quot;-&quot; * 50 + &quot;\n\n&quot;)&#10;                f.write(cover_letter)&#10;&#10;            print(f&quot;✅ Cover letter saved: {filepath}&quot;)&#10;&#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;cover_letter&quot;: cover_letter,&#10;                &quot;filepath&quot;: str(filepath),&#10;                &quot;company_info&quot;: company_info,&#10;                &quot;job_id&quot;: job_posting.job_id&#10;            }&#10;&#10;        except Exception as e:&#10;            print(f&quot;❌ Error generating cover letter for {job_posting.job_title}: {e}&quot;)&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;error&quot;: str(e),&#10;                &quot;job_id&quot;: job_posting.job_id,&#10;                &quot;company&quot;: job_posting.company_name,&#10;                &quot;title&quot;: job_posting.job_title&#10;            }&#10;&#10;    async def process_job_batch(self, job_postings: List[JobPosting], delay: int = 2) -&gt; List[Dict]:&#10;        &quot;&quot;&quot;Process multiple job postings with rate limiting&quot;&quot;&quot;&#10;        results = []&#10;&#10;        print(f&quot; Starting batch processing for {len(job_postings)} jobs...&quot;)&#10;&#10;        for i, job_posting in enumerate(job_postings):&#10;            print(f&quot;\n Processing {i+1}/{len(job_postings)}: {job_posting.company_name} - {job_posting.job_title}&quot;)&#10;&#10;            result = await self.generate_cover_letter(job_posting)&#10;            results.append(result)&#10;&#10;            # Rate limiting&#10;            if i &lt; len(job_postings) - 1:&#10;                print(f&quot;⏳ Waiting {delay} seconds before next job...&quot;)&#10;                time.sleep(delay)&#10;&#10;        return results&#10;&#10;    @classmethod&#10;    def load_jobs_from_processed_file(cls, processed_jobs_file: str = &quot;processed_jobs.json&quot;) -&gt; List[JobPosting]:&#10;        &quot;&quot;&quot;Load jobs from your processed_jobs.json file and read descriptions from job_contents&quot;&quot;&quot;&#10;        job_postings = []&#10;&#10;        try:&#10;            with open(processed_jobs_file, 'r', encoding='utf-8') as f:&#10;                processed_jobs = json.load(f)&#10;&#10;            print(f&quot; Loading {len(processed_jobs)} jobs from {processed_jobs_file}&quot;)&#10;&#10;            generator_temp = cls(&quot;dummy_key&quot;, None)  # Temporary instance just for loading descriptions&#10;&#10;            for job_id, job_info in processed_jobs.items():&#10;                # Load job description from markdown file&#10;                job_description = generator_temp.load_job_description(job_info[&quot;job_title&quot;], job_id)&#10;&#10;                if job_description:&#10;                    job_posting = JobPosting(&#10;                        company_name=job_info[&quot;company&quot;],&#10;                        job_title=job_info[&quot;job_title&quot;],&#10;                        job_description=job_description,&#10;                        job_id=job_id,&#10;                        link=job_info.get(&quot;link&quot;)&#10;                    )&#10;                    job_postings.append(job_posting)&#10;                    print(f&quot;✅ Loaded: {job_info['job_title']} at {job_info['company']}&quot;)&#10;                else:&#10;                    print(f&quot;⚠️ Skipped (no description): {job_info['job_title']} at {job_info['company']}&quot;)&#10;&#10;            print(f&quot;✅ Successfully loaded {len(job_postings)} jobs with descriptions&quot;)&#10;            return job_postings&#10;&#10;        except Exception as e:&#10;            print(f&quot;❌ Error loading jobs from {processed_jobs_file}: {e}&quot;)&#10;            return []" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/prompts.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/prompts.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Cover Letter Generation Prompts&#10;All prompts used by the cover letter generator system.&#10;&quot;&quot;&quot;&#10;&#10;COMPANY_RESEARCH_PROMPT = &quot;&quot;&quot;&#10;You are a research assistant helping to gather information about companies for job applications.&#10;&#10;Given this company name: {company_name}&#10;&#10;Please research and provide the following information in JSON format:&#10;{{&#10;    &quot;company_overview&quot;: &quot;Brief description of what the company does&quot;,&#10;    &quot;mission_values&quot;: &quot;Company's stated mission, values, or purpose&quot;,&#10;    &quot;recent_projects&quot;: &quot;Any notable recent projects, initiatives, or news&quot;,&#10;    &quot;culture_highlights&quot;: &quot;Information about company culture, work environment, or employee benefits&quot;,&#10;    &quot;industry_context&quot;: &quot;What industry they're in and their position/reputation&quot;,&#10;    &quot;unique_aspects&quot;: &quot;What makes this company unique or different from competitors&quot;&#10;}}&#10;&#10;Focus on finding authentic, specific details that would be relevant for a job application. &#10;Avoid generic corporate speak and look for concrete examples of the company's work and values.&#10;If you cannot find specific information for any category, put &quot;Not found&quot; as the value.&#10;&quot;&quot;&quot;&#10;&#10;COVER_LETTER_GENERATION_PROMPT = &quot;&quot;&quot;&#10;You are an expert cover letter writer. Your job is to generate a focused, professional cover letter that proves the candidate can do the job.&#10;&#10;This is NOT about feelings, values, or motivation. This is about demonstrating capability through concrete examples.&#10;&#10;Look at the candidates' key projects and work experience, then select experience most relevant to the job posting.&#10;&#10;REMEMBER: This is for an INTERNSHIP position. Show potential and eagerness to learn, not expertise.&#10;&#10;---&#10;&#10;**INPUTS**&#10;&#10;PERSONAL CONTEXT:&#10;{personal_context}&#10;&#10;JOB POSTING:&#10;Company: {company_name}&#10;Position: {job_title}&#10;Description: {job_description}&#10;&#10;COMPANY RESEARCH:&#10;{company_research}&#10;&#10;USER NAME: {user_name}&#10;&#10;---&#10;&#10;**COVER LETTER STRUCTURE (4 PARTS)**&#10;&#10;1. **Opening** – State who you are and what caught your attention about this specific role&#10;   - Focus on a concrete requirement or responsibility from the job posting&#10;   - Skip feelings—go straight to relevant experience&#10;&#10;2. **Proof Point #1** – Your most relevant project/experience  &#10;   - What you built/did, with what technologies&#10;   - Quantified results (numbers, metrics, outcomes)&#10;   - How this experience prepares you for job requirements&#10;&#10;3. **Proof Point #2** – Second most relevant example&#10;   - Different skill set or type of contribution  &#10;   - Again: concrete actions and measurable results&#10;   - Connect to different job requirements&#10;&#10;4. **Company Connection** – One brief paragraph mentioning:&#10;   - Specific company project, technology, or practice you researched&#10;   - How your background gives you a foundation to contribute to that work&#10;   - Show eagerness to learn and grow in this area&#10;&#10;5. **Closing** – Two parts:&#10;   - One sentence about specific culture/values alignment (ONLY if relevant and specific)&#10;   - Express interest in learning and contributing to their team&#10;   - &quot;Best regards, {user_name}&quot;&#10;&#10;---&#10;&#10;**WRITING RULES - FOLLOW THESE EXACTLY:**&#10;&#10;**BANNED WORDS/PHRASES - NEVER USE:**&#10;- passionate, excited, drawn to, appeals, resonates, aligns, fits, matches&#10;- innovative, cutting-edge, dynamic, forward-thinking, impactful&#10;- mission, inspiring, meaningful, leverage, drive success&#10;- I believe, I feel, eager to contribute, excited to leverage&#10;- perfectly, always, exactly, completely, absolutely, extremely&#10;- deeply, truly, really, very, highly, strongly&#10;- positions me well, equipped me with, honed my skills&#10;&#10;**INTERNSHIP-APPROPRIATE LANGUAGE:**&#10;- Instead of &quot;my expertise&quot; → &quot;my experience with&quot; or &quot;my background in&quot;&#10;- Instead of &quot;I'm qualified&quot; → &quot;I'm prepared&quot; or &quot;this experience gives me a foundation&quot;&#10;- Show learning mindset: &quot;I'm eager to learn&quot;, &quot;I'm ready to develop&quot;, &quot;I want to build on&quot;&#10;- Be humble but confident: &quot;This project gave me exposure to...&quot; rather than &quot;I mastered...&quot;&#10;&#10;**HANDLING MISSING TECHNOLOGIES:**&#10;- If job requires technology candidate hasn't used: demonstrate learning ability through examples&#10;- Show how you've quickly picked up new technologies in past projects&#10;- Use phrases like: &quot;I'm confident I can quickly learn [technology] given my experience picking up [similar technology] in [timeframe]&quot;&#10;- Connect to similar technologies you have used: &quot;While I haven't used [X], my experience with [similar Y] gives me a strong foundation&quot;&#10;- Emphasize learning speed with concrete examples: &quot;During [project], I learned [technology] in [specific timeframe] to deliver [result]&quot;&#10;&#10;**REQUIRED STYLE:**&#10;- Every sentence must state a fact or describe an action you took&#10;- Include specific technologies, numbers, results whenever possible  &#10;- Use active voice (&quot;I built&quot; not &quot;I was responsible for&quot;)&#10;- No explanations of why you like the company—only what you can contribute and learn&#10;- Replace feelings with capabilities: Instead of &quot;I'm excited about X&quot; → &quot;I can contribute to X because I built Y&quot;&#10;- Show growth potential, not just current ability&#10;&#10;**TONE:** Professional, direct, humble, eager to learn. Show potential, not mastery.&#10;&#10;**VALUES ALIGNMENT EXCEPTION:**&#10;- ONLY in the closing paragraph, you may mention values alignment IF:&#10;  - The company has a specific, concrete value (e.g., &quot;employee development&quot;, &quot;work-life balance&quot;, &quot;transparency&quot;)&#10;  - You can connect it to a specific personal value from the candidate's context&#10;  - You use direct language: &quot;I share [Company's] commitment to [specific value]&quot; &#10;- NEVER use: &quot;aligns with my values&quot;, &quot;resonates with&quot;, &quot;I'm drawn to your values&quot;&#10;- KEEP IT TO ONE SENTENCE MAXIMUM&#10;&#10;**TECHNICAL NOTES:**&#10;- Bold key technical skills/technologies sparingly&#10;- Imply GPA if high: &quot;McGill Software Engineering student (3.88 GPA)&quot;&#10;- 3-4 paragraphs maximum&#10;- Start with &quot;Dear Hiring Manager&quot; or &quot;Dear Recruitement team at COMPANY&quot;&#10;- End: &quot;Best regards,&quot; + line break + &quot;{user_name}&quot;&#10;- Return only letter body—no header/contact info&#10;&#10;---&#10;&#10;Return only the cover letter text. No extra notes or explanation.&#10;&quot;&quot;&quot;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Cover Letter Generation Prompts&#10;All prompts used by the cover letter generator system.&#10;&quot;&quot;&quot;&#10;&#10;COMPANY_RESEARCH_PROMPT = &quot;&quot;&quot;&#10;You are a research assistant helping to gather information about companies for job applications.&#10;&#10;Given this company name: {company_name}&#10;&#10;Please research and provide the following information in JSON format:&#10;{{&#10;    &quot;company_overview&quot;: &quot;Brief description of what the company does&quot;,&#10;    &quot;mission_values&quot;: &quot;Company's stated mission, values, or purpose&quot;,&#10;    &quot;recent_projects&quot;: &quot;Any notable recent projects, initiatives, or news&quot;,&#10;    &quot;culture_highlights&quot;: &quot;Information about company culture, work environment, or employee benefits&quot;,&#10;    &quot;industry_context&quot;: &quot;What industry they're in and their position/reputation&quot;,&#10;    &quot;unique_aspects&quot;: &quot;What makes this company unique or different from competitors&quot;&#10;}}&#10;&#10;Focus on finding authentic, specific details that would be relevant for a job application. &#10;Avoid generic corporate speak and look for concrete examples of the company's work and values.&#10;If you cannot find specific information for any category, put &quot;Not found&quot; as the value.&#10;&quot;&quot;&quot;&#10;&#10;COVER_LETTER_GENERATION_PROMPT = &quot;&quot;&quot;&#10;You are an expert cover letter writer. Your job is to generate a focused, professional cover letter that proves the candidate can do the job.&#10;&#10;This is NOT about feelings, values, or motivation. This is about demonstrating capability through concrete examples.&#10;&#10;Look at the candidates' key projects and work experience, then select experience most relevant to the job posting.&#10;&#10;REMEMBER: This is for an INTERNSHIP position. Show potential and eagerness to learn, not expertise.&#10;&#10;**LANGUAGE DETECTION:**&#10;- If the job description is primarily in FRENCH, write the ENTIRE cover letter in French&#10;- If the job description is primarily in ENGLISH, write the ENTIRE cover letter in English&#10;- Match the language of the job posting exactly&#10;&#10;---&#10;&#10;**INPUTS**&#10;&#10;PERSONAL CONTEXT:&#10;{personal_context}&#10;&#10;JOB POSTING:&#10;Company: {company_name}&#10;Position: {job_title}&#10;Description: {job_description}&#10;&#10;COMPANY RESEARCH:&#10;{company_research}&#10;&#10;USER NAME: {user_name}&#10;&#10;---&#10;&#10;**COVER LETTER STRUCTURE (4 PARTS)**&#10;&#10;1. **Opening** – State who you are and what caught your attention about this specific role&#10;   - Focus on a concrete requirement or responsibility from the job posting&#10;   - Skip feelings—go straight to relevant experience&#10;&#10;2. **Proof Point #1** – Your most relevant project/experience  &#10;   - What you built/did, with what technologies&#10;   - Quantified results (numbers, metrics, outcomes)&#10;   - How this experience prepares you for job requirements&#10;&#10;3. **Proof Point #2** – Second most relevant example&#10;   - Different skill set or type of contribution  &#10;   - Again: concrete actions and measurable results&#10;   - Connect to different job requirements&#10;&#10;4. **Company Connection** – One brief paragraph mentioning:&#10;   - Specific company project, technology, or practice you researched&#10;   - How your background gives you a foundation to contribute to that work&#10;   - Show eagerness to learn and grow in this area&#10;&#10;5. **Closing** – Two parts:&#10;   - One sentence about specific culture/values alignment (ONLY if relevant and specific)&#10;   - Express interest in learning and contributing to their team&#10;   - &quot;Best regards, {user_name}&quot; (English) or &quot;Cordialement, {user_name}&quot; (French)&#10;&#10;---&#10;&#10;**WRITING RULES - FOLLOW THESE EXACTLY:**&#10;&#10;**BANNED WORDS/PHRASES - NEVER USE:**&#10;- passionate, excited, drawn to, appeals, resonates, aligns, fits, matches&#10;- innovative, cutting-edge, dynamic, forward-thinking, impactful&#10;- mission, inspiring, meaningful, leverage, drive success&#10;- I believe, I feel, eager to contribute, excited to leverage&#10;- perfectly, always, exactly, completely, absolutely, extremely&#10;- deeply, truly, really, very, highly, strongly&#10;- positions me well, equipped me with, honed my skills&#10;&#10;**INTERNSHIP-APPROPRIATE LANGUAGE:**&#10;- Instead of &quot;my expertise&quot; → &quot;my experience with&quot; or &quot;my background in&quot;&#10;- Instead of &quot;I'm qualified&quot; → &quot;I'm prepared&quot; or &quot;this experience gives me a foundation&quot;&#10;- Show learning mindset: &quot;I'm eager to learn&quot;, &quot;I'm ready to develop&quot;, &quot;I want to build on&quot;&#10;- Be humble but confident: &quot;This project gave me exposure to...&quot; rather than &quot;I mastered...&quot;&#10;&#10;**HANDLING MISSING TECHNOLOGIES:**&#10;- If job requires technology candidate hasn't used: demonstrate learning ability through examples&#10;- Show how you've quickly picked up new technologies in past projects&#10;- Use phrases like: &quot;I'm confident I can quickly learn [technology] given my experience picking up [similar technology] in [timeframe]&quot;&#10;- Connect to similar technologies you have used: &quot;While I haven't used [X], my experience with [similar Y] gives me a strong foundation&quot;&#10;- Emphasize learning speed with concrete examples: &quot;During [project], I learned [technology] in [specific timeframe] to deliver [result]&quot;&#10;&#10;**REQUIRED STYLE:**&#10;- Every sentence must state a fact or describe an action you took&#10;- Include specific technologies, numbers, results whenever possible  &#10;- Use active voice (&quot;I built&quot; not &quot;I was responsible for&quot;)&#10;- No explanations of why you like the company—only what you can contribute and learn&#10;- Replace feelings with capabilities: Instead of &quot;I'm excited about X&quot; → &quot;I can contribute to X because I built Y&quot;&#10;- Show growth potential, not just current ability&#10;&#10;**TONE:** Professional, direct, humble, eager to learn. Show potential, not mastery.&#10;&#10;**VALUES ALIGNMENT EXCEPTION:**&#10;- ONLY in the closing paragraph, you may mention values alignment IF:&#10;  - The company has a specific, concrete value (e.g., &quot;employee development&quot;, &quot;work-life balance&quot;, &quot;transparency&quot;)&#10;  - You can connect it to a specific personal value from the candidate's context&#10;  - You use direct language: &quot;I share [Company's] commitment to [specific value]&quot; &#10;- NEVER use: &quot;aligns with my values&quot;, &quot;resonates with&quot;, &quot;I'm drawn to your values&quot;&#10;- KEEP IT TO ONE SENTENCE MAXIMUM&#10;&#10;**TECHNICAL NOTES:**&#10;- Bold key technical skills/technologies sparingly&#10;- Imply GPA if high: &quot;McGill Software Engineering student (3.88 GPA)&quot;&#10;- 3-4 paragraphs maximum&#10;- Start with &quot;Dear Hiring Manager&quot; or &quot;Dear Recruitment team at COMPANY&quot;&#10;- End: &quot;Best regards,&quot; + line break + &quot;{user_name}&quot; (English) or &quot;Cordialement,&quot; + line break + &quot;{user_name}&quot; (French)&#10;- Return only letter body—no header/contact info&#10;&#10;---&#10;&#10;Return only the cover letter text. No extra notes or explanation.&#10;&quot;&quot;&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/prompts_new.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/prompts_new.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Cover Letter Generation Prompts&#10;All prompts used by the cover letter generator system.&#10;&quot;&quot;&quot;&#10;&#10;COMPANY_RESEARCH_PROMPT = &quot;&quot;&quot;&#10;You are a research assistant helping to gather information about companies for job applications.&#10;&#10;Given this company name: {company_name}&#10;&#10;Please research and provide the following information in JSON format:&#10;{{&#10;    &quot;company_overview&quot;: &quot;Brief description of what the company does&quot;,&#10;    &quot;mission_values&quot;: &quot;Company's stated mission, values, or purpose&quot;,&#10;    &quot;recent_projects&quot;: &quot;Any notable recent projects, initiatives, or news&quot;,&#10;    &quot;culture_highlights&quot;: &quot;Information about company culture, work environment, or employee benefits&quot;,&#10;    &quot;industry_context&quot;: &quot;What industry they're in and their position/reputation&quot;,&#10;    &quot;unique_aspects&quot;: &quot;What makes this company unique or different from competitors&quot;&#10;}}&#10;&#10;Focus on finding authentic, specific details that would be relevant for a job application. &#10;Avoid generic corporate speak and look for concrete examples of the company's work and values.&#10;If you cannot find specific information for any category, put &quot;Not found&quot; as the value.&#10;&quot;&quot;&quot;&#10;&#10;COVER_LETTER_GENERATION_PROMPT_ENGLISH = &quot;&quot;&quot;&#10;You are an expert cover letter writer. Your job is to generate a focused, professional cover letter that proves the candidate can do the job.&#10;&#10;This is NOT about feelings, values, or motivation. This is about demonstrating capability through concrete examples.&#10;&#10;Look at the candidates' key projects and work experience, then select experience most relevant to the job posting.&#10;&#10;REMEMBER: This is for an INTERNSHIP position. Show potential and eagerness to learn, not expertise.&#10;&#10;---&#10;&#10;**INPUTS**&#10;&#10;PERSONAL CONTEXT:&#10;{personal_context}&#10;&#10;JOB POSTING:&#10;Company: {company_name}&#10;Position: {job_title}&#10;Description: {job_description}&#10;&#10;COMPANY RESEARCH:&#10;{company_research}&#10;&#10;USER NAME: {user_name}&#10;&#10;---&#10;&#10;**COVER LETTER STRUCTURE (4 PARTS)**&#10;&#10;1. **Opening** – State who you are and what caught your attention about this specific role&#10;   - Focus on a concrete requirement or responsibility from the job posting&#10;   - Skip feelings—go straight to relevant experience&#10;&#10;2. **Proof Point #1** – Your most relevant project/experience  &#10;   - What you built/did, with what technologies&#10;   - Quantified results (numbers, metrics, outcomes)&#10;   - How this experience prepares you for job requirements&#10;&#10;3. **Proof Point #2** – Second most relevant example&#10;   - Different skill set or type of contribution  &#10;   - Again: concrete actions and measurable results&#10;   - Connect to different job requirements&#10;&#10;4. **Company Connection** – One brief paragraph mentioning:&#10;   - Specific company project, technology, or practice you researched&#10;   - How your background gives you a foundation to contribute to that work&#10;   - Show eagerness to learn and grow in this area&#10;&#10;5. **Closing** – Two parts:&#10;   - One sentence about specific culture/values alignment (ONLY if relevant and specific)&#10;   - Express interest in learning and contributing to their team&#10;   - &quot;Best regards, {user_name}&quot;&#10;&#10;---&#10;&#10;**WRITING RULES - FOLLOW THESE EXACTLY:**&#10;&#10;**BANNED WORDS/PHRASES - NEVER USE:**&#10;- passionate, excited, drawn to, appeals, resonates, aligns, fits, matches&#10;- innovative, cutting-edge, dynamic, forward-thinking, impactful&#10;- mission, inspiring, meaningful, leverage, drive success&#10;- I believe, I feel, eager to contribute, excited to leverage&#10;- perfectly, always, exactly, completely, absolutely, extremely&#10;- deeply, truly, really, very, highly, strongly&#10;- positions me well, equipped me with, honed my skills&#10;&#10;**INTERNSHIP-APPROPRIATE LANGUAGE:**&#10;- Instead of &quot;my expertise&quot; → &quot;my experience with&quot; or &quot;my background in&quot;&#10;- Instead of &quot;I'm qualified&quot; → &quot;I'm prepared&quot; or &quot;this experience gives me a foundation&quot;&#10;- Show learning mindset: &quot;I'm eager to learn&quot;, &quot;I'm ready to develop&quot;, &quot;I want to build on&quot;&#10;- Be humble but confident: &quot;This project gave me exposure to...&quot; rather than &quot;I mastered...&quot;&#10;&#10;**HANDLING MISSING TECHNOLOGIES:**&#10;- If job requires technology candidate hasn't used: demonstrate learning ability through examples&#10;- Show how you've quickly picked up new technologies in past projects&#10;- Use phrases like: &quot;I'm confident I can quickly learn [technology] given my experience picking up [similar technology] in [timeframe]&quot;&#10;- Connect to similar technologies you have used: &quot;While I haven't used [X], my experience with [similar Y] gives me a strong foundation&quot;&#10;- Emphasize learning speed with concrete examples: &quot;During [project], I learned [technology] in [specific timeframe] to deliver [result]&quot;&#10;&#10;**REQUIRED STYLE:**&#10;- Every sentence must state a fact or describe an action you took&#10;- Include specific technologies, numbers, results whenever possible  &#10;- Use active voice (&quot;I built&quot; not &quot;I was responsible for&quot;)&#10;- No explanations of why you like the company—only what you can contribute and learn&#10;- Replace feelings with capabilities: Instead of &quot;I'm excited about X&quot; → &quot;I can contribute to X because I built Y&quot;&#10;- Show growth potential, not just current ability&#10;&#10;**TONE:** Professional, direct, humble, eager to learn. Show potential, not mastery.&#10;&#10;**VALUES ALIGNMENT EXCEPTION:**&#10;- ONLY in the closing paragraph, you may mention values alignment IF:&#10;  - The company has a specific, concrete value (e.g., &quot;employee development&quot;, &quot;work-life balance&quot;, &quot;transparency&quot;)&#10;  - You can connect it to a specific personal value from the candidate's context&#10;  - You use direct language: &quot;I share [Company's] commitment to [specific value]&quot; &#10;- NEVER use: &quot;aligns with my values&quot;, &quot;resonates with&quot;, &quot;I'm drawn to your values&quot;&#10;- KEEP IT TO ONE SENTENCE MAXIMUM&#10;&#10;**TECHNICAL NOTES:**&#10;- Bold key technical skills/technologies sparingly&#10;- Imply GPA if high: &quot;McGill Software Engineering student (3.88 GPA)&quot;&#10;- 3-4 paragraphs maximum&#10;- Start with &quot;Dear Hiring Manager&quot; or &quot;Dear Recruitment team at COMPANY&quot;&#10;- End: &quot;Best regards,&quot; + line break + &quot;{user_name}&quot;&#10;- Return only letter body—no header/contact info&#10;&#10;---&#10;&#10;Return only the cover letter text. No extra notes or explanation.&#10;&quot;&quot;&quot;&#10;&#10;COVER_LETTER_GENERATION_PROMPT_FRENCH = &quot;&quot;&quot;&#10;Vous êtes un expert en rédaction de lettres de motivation. Votre travail consiste à créer une lettre de motivation professionnelle et ciblée qui prouve que le candidat peut faire le travail.&#10;&#10;Il ne s'agit PAS de sentiments, de valeurs ou de motivation. Il s'agit de démontrer ses capacités par des exemples concrets.&#10;&#10;Examinez les projets clés et l'expérience professionnelle du candidat, puis sélectionnez l'expérience la plus pertinente pour l'offre d'emploi.&#10;&#10;RAPPELEZ-VOUS : Il s'agit d'un poste de STAGE. Montrez le potentiel et l'envie d'apprendre, pas l'expertise.&#10;&#10;---&#10;&#10;**DONNÉES D'ENTRÉE**&#10;&#10;CONTEXTE PERSONNEL :&#10;{personal_context}&#10;&#10;OFFRE D'EMPLOI :&#10;Entreprise : {company_name}&#10;Poste : {job_title}&#10;Description : {job_description}&#10;&#10;RECHERCHE SUR L'ENTREPRISE :&#10;{company_research}&#10;&#10;NOM DE L'UTILISATEUR : {user_name}&#10;&#10;---&#10;&#10;**STRUCTURE DE LA LETTRE DE MOTIVATION (4 PARTIES)**&#10;&#10;1. **Ouverture** – Présentez-vous et expliquez ce qui a attiré votre attention sur ce poste spécifique&#10;   - Concentrez-vous sur une exigence ou responsabilité concrète de l'offre d'emploi&#10;   - Évitez les sentiments—allez directement à l'expérience pertinente&#10;&#10;2. **Preuve #1** – Votre projet/expérience le plus pertinent&#10;   - Ce que vous avez construit/fait, avec quelles technologies&#10;   - Résultats quantifiés (chiffres, métriques, résultats)&#10;   - Comment cette expérience vous prépare aux exigences du poste&#10;&#10;3. **Preuve #2** – Deuxième exemple le plus pertinent&#10;   - Ensemble de compétences ou type de contribution différent&#10;   - Encore : actions concrètes et résultats mesurables&#10;   - Lien avec différentes exigences du poste&#10;&#10;4. **Connexion avec l'entreprise** – Un bref paragraphe mentionnant :&#10;   - Projet, technologie ou pratique spécifique de l'entreprise que vous avez recherché&#10;   - Comment votre formation vous donne une base pour contribuer à ce travail&#10;   - Montrez votre désir d'apprendre et de grandir dans ce domaine&#10;&#10;5. **Conclusion** – Deux parties :&#10;   - Une phrase sur l'alignement culturel/valeurs spécifique (SEULEMENT si pertinent et spécifique)&#10;   - Exprimez votre intérêt à apprendre et contribuer à leur équipe&#10;   - &quot;Cordialement, {user_name}&quot;&#10;&#10;---&#10;&#10;**RÈGLES D'ÉCRITURE - SUIVEZ-LES EXACTEMENT :**&#10;&#10;**MOTS/PHRASES INTERDITS - À NE JAMAIS UTILISER :**&#10;- passionné, enthousiaste, attiré par, plaît, résonne, s'aligne, correspond&#10;- innovant, avant-gardiste, dynamique, visionnaire, impactant&#10;- mission, inspirant, significatif, exploiter, conduire au succès&#10;- je crois, je sens, désireux de contribuer, enthousiaste à l'idée d'exploiter&#10;- parfaitement, toujours, exactement, complètement, absolument, extrêmement&#10;- profondément, vraiment, réellement, très, hautement, fortement&#10;- me positionne bien, m'a équipé de, a affûté mes compétences&#10;&#10;**LANGAGE APPROPRIÉ POUR UN STAGE :**&#10;- Au lieu de &quot;mon expertise&quot; → &quot;mon expérience avec&quot; ou &quot;ma formation en&quot;&#10;- Au lieu de &quot;je suis qualifié&quot; → &quot;je suis préparé&quot; ou &quot;cette expérience me donne une base&quot;&#10;- Montrez un état d'esprit d'apprentissage : &quot;j'ai hâte d'apprendre&quot;, &quot;je suis prêt à développer&quot;, &quot;je veux construire sur&quot;&#10;- Soyez humble mais confiant : &quot;Ce projet m'a donné une exposition à...&quot; plutôt que &quot;j'ai maîtrisé...&quot;&#10;&#10;**GESTION DES TECHNOLOGIES MANQUANTES :**&#10;- Si le poste nécessite une technologie que le candidat n'a pas utilisée : démontrez la capacité d'apprentissage par des exemples&#10;- Montrez comment vous avez rapidement assimilé de nouvelles technologies dans des projets passés&#10;- Utilisez des phrases comme : &quot;Je suis confiant de pouvoir rapidement apprendre [technologie] étant donné mon expérience à assimiler [technologie similaire] en [délai]&quot;&#10;- Connectez aux technologies similaires que vous connaissez : &quot;Bien que je n'aie pas utilisé [X], mon expérience avec [Y similaire] me donne une base solide&quot;&#10;- Soulignez la vitesse d'apprentissage avec des exemples concrets : &quot;Pendant [projet], j'ai appris [technologie] en [délai spécifique] pour livrer [résultat]&quot;&#10;&#10;**STYLE REQUIS :**&#10;- Chaque phrase doit énoncer un fait ou décrire une action que vous avez prise&#10;- Incluez des technologies spécifiques, des chiffres, des résultats chaque fois que possible&#10;- Utilisez la voix active (&quot;j'ai construit&quot; pas &quot;j'étais responsable de&quot;)&#10;- Pas d'explications sur pourquoi vous aimez l'entreprise—seulement ce que vous pouvez contribuer et apprendre&#10;- Remplacez les sentiments par des capacités : Au lieu de &quot;je suis enthousiaste à propos de X&quot; → &quot;je peux contribuer à X parce que j'ai construit Y&quot;&#10;- Montrez le potentiel de croissance, pas seulement la capacité actuelle&#10;&#10;**TON :** Professionnel, direct, humble, désireux d'apprendre. Montrez le potentiel, pas la maîtrise.&#10;&#10;**EXCEPTION POUR L'ALIGNEMENT DES VALEURS :**&#10;- SEULEMENT dans le paragraphe de conclusion, vous pouvez mentionner l'alignement des valeurs SI :&#10;  - L'entreprise a une valeur spécifique et concrète (ex: &quot;développement des employés&quot;, &quot;équilibre travail-vie&quot;, &quot;transparence&quot;)&#10;  - Vous pouvez la connecter à une valeur personnelle spécifique du contexte du candidat&#10;  - Vous utilisez un langage direct : &quot;Je partage l'engagement de [Entreprise] envers [valeur spécifique]&quot;&#10;- NE JAMAIS utiliser : &quot;s'aligne avec mes valeurs&quot;, &quot;résonne avec&quot;, &quot;je suis attiré par vos valeurs&quot;&#10;- LIMITEZ-VOUS À UNE PHRASE MAXIMUM&#10;&#10;**NOTES TECHNIQUES :**&#10;- Mettez en gras les compétences/technologies techniques clés avec parcimonie&#10;- Impliquez la note si elle est élevée : &quot;étudiant en génie logiciel à McGill (3,88 GPA)&quot;&#10;- 3-4 paragraphes maximum&#10;- Commencez par &quot;Chère équipe de recrutement&quot; or &quot;Cher responsable du recrutement chez ENTREPRISE&quot;&#10;- Terminez par : &quot;Cordialement,&quot; + saut de ligne + &quot;{user_name}&quot;&#10;- Retournez seulement le corps de la lettre—pas d'en-tête/info de contact&#10;&#10;---&#10;&#10;Retournez seulement le texte de la lettre de motivation. Aucune note ou explication supplémentaire.&#10;&quot;&quot;&quot;&#10;&#10;# Legacy prompt - for backward compatibility&#10;COVER_LETTER_GENERATION_PROMPT = COVER_LETTER_GENERATION_PROMPT_ENGLISH" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/setup_env.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/setup_env.py" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Setup script to test the LinkedIn Bot pipeline environment&#10;&quot;&quot;&quot;&#10;&#10;import os&#10;import sys&#10;&#10;def check_environment():&#10;    print(&quot;=== LinkedIn Bot Pipeline Environment Check ===\n&quot;)&#10;    &#10;    # Check Python version&#10;    print(f&quot;Python version: {sys.version}&quot;)&#10;    &#10;    # Check if required files exist&#10;    required_files = [&#10;        'config.json',&#10;        'linkedin_bot.py', &#10;        'cover_letter_generator.py',&#10;        'personal_context.py',&#10;        'processed_jobs.json',&#10;        'run_cover_letter_generation.py'&#10;    ]&#10;    &#10;    print(&quot;\n Checking required files:&quot;)&#10;    for file in required_files:&#10;        exists = os.path.exists(file)&#10;        status = &quot;✅&quot; if exists else &quot;❌&quot;&#10;        print(f&quot;   {status} {file}&quot;)&#10;    &#10;    # Check directories&#10;    required_dirs = ['job_contents', 'cookies']&#10;    print(&quot;\n Checking directories:&quot;)&#10;    for dir_name in required_dirs:&#10;        exists = os.path.exists(dir_name)&#10;        status = &quot;✅&quot; if exists else &quot;❌&quot;&#10;        count = len(os.listdir(dir_name)) if exists else 0&#10;        print(f&quot;   {status} {dir_name}/ ({count} files)&quot;)&#10;    &#10;    # Check API key&#10;    api_key = os.getenv('OPENAI_API_KEY')&#10;    print(f&quot;\n OpenAI API Key: {'✅ Set' if api_key else '❌ Not set'}&quot;)&#10;    if api_key:&#10;        print(f&quot;   Key starts with: {api_key[:20]}...&quot;)&#10;    &#10;    # Check job data&#10;    if os.path.exists('processed_jobs.json'):&#10;        import json&#10;        with open('processed_jobs.json', 'r') as f:&#10;            jobs = json.load(f)&#10;        print(f&quot;\n Job data: {len(jobs)} processed jobs found&quot;)&#10;    &#10;    print(&quot;\n&quot; + &quot;=&quot;*50)&#10;    return True&#10;&#10;def test_imports():&#10;    print(&quot;\n Testing imports...&quot;)&#10;    &#10;    try:&#10;        import selenium&#10;        print(&quot;   ✅ Selenium imported successfully&quot;)&#10;    except ImportError:&#10;        print(&quot;   ❌ Selenium not found - install with: pip install selenium&quot;)&#10;    &#10;    try:&#10;        import openai&#10;        print(&quot;   ✅ OpenAI imported successfully&quot;)&#10;    except ImportError:&#10;        print(&quot;   ❌ OpenAI not found - install with: pip install openai&quot;)&#10;    &#10;    try:&#10;        from cover_letter_generator import CoverLetterGenerator&#10;        print(&quot;   ✅ CoverLetterGenerator imported successfully&quot;)&#10;    except ImportError as e:&#10;        print(f&quot;   ❌ CoverLetterGenerator import failed: {e}&quot;)&#10;    &#10;    try:&#10;        from personal_context import PERSONAL_CONTEXT&#10;        print(&quot;   ✅ PersonalContext imported successfully&quot;)&#10;    except ImportError as e:&#10;        print(f&quot;   ❌ PersonalContext import failed: {e}&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Set API key from .env file if not already set&#10;    if not os.getenv('OPENAI_API_KEY'):&#10;        env_file = '.env'&#10;        if os.path.exists(env_file):&#10;            with open(env_file, 'r') as f:&#10;                for line in f:&#10;                    if line.startswith('OPENAI_API_KEY='):&#10;                        api_key = line.split('=', 1)[1].strip()&#10;                        os.environ['OPENAI_API_KEY'] = api_key&#10;                        print(&quot; API key loaded from .env file&quot;)&#10;                        break&#10;    &#10;    check_environment()&#10;    test_imports()&#10;    &#10;    print(&quot;\n Ready to test the pipeline!&quot;)&#10;    print(&quot;\nNext steps:&quot;)&#10;    print(&quot;1. If you see any ❌ above, fix those issues first&quot;)&#10;    print(&quot;2. Run: python3 test_cover_letter_generation.py&quot;)&#10;    print(&quot;3. Or run the full pipeline with: python3 run_cover_letter_generation.py&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/shared_utils.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/shared_utils.py" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="import json&#10;import re&#10;from pathlib import Path&#10;from datetime import datetime, timedelta&#10;from typing import Dict, Optional, Any&#10;&#10;&#10;class FileUtils:&#10;    &quot;&quot;&quot;Utility class for file operations&quot;&quot;&quot;&#10;    &#10;    @staticmethod&#10;    def load_json(file_path: Path, default: Any = None) -&gt; Any:&#10;        &quot;&quot;&quot;Load JSON file with error handling&quot;&quot;&quot;&#10;        try:&#10;            with open(file_path, 'r', encoding='utf-8') as f:&#10;                return json.load(f)&#10;        except FileNotFoundError:&#10;            print(f&quot;File {file_path} not found. Using default values.&quot;)&#10;            return default or {}&#10;        except json.JSONDecodeError:&#10;            print(f&quot;Error reading {file_path}. Using default values.&quot;)&#10;            return default or {}&#10;    &#10;    @staticmethod&#10;    def save_json(file_path: Path, data: Any, indent: int = 2):&#10;        &quot;&quot;&quot;Save data to JSON file with error handling&quot;&quot;&quot;&#10;        try:&#10;            file_path.parent.mkdir(parents=True, exist_ok=True)&#10;            with open(file_path, 'w', encoding='utf-8') as f:&#10;                json.dump(data, f, indent=indent, ensure_ascii=False)&#10;        except Exception as e:&#10;            print(f&quot;❌ Error saving to {file_path}: {e}&quot;)&#10;            raise&#10;    &#10;    @staticmethod&#10;    def save_text(file_path: Path, content: str):&#10;        &quot;&quot;&quot;Save text content to file&quot;&quot;&quot;&#10;        file_path.parent.mkdir(parents=True, exist_ok=True)&#10;        with open(file_path, 'w', encoding='utf-8') as f:&#10;            f.write(content)&#10;&#10;&#10;class StringUtils:&#10;    &quot;&quot;&quot;Utility class for string operations&quot;&quot;&quot;&#10;    &#10;    @staticmethod&#10;    def get_safe_filename(text: str) -&gt; str:&#10;        &quot;&quot;&quot;Convert text to safe filename by removing/replacing unsafe characters&quot;&quot;&quot;&#10;        safe_text = &quot;&quot;.join(c for c in text if c.isalnum() or c in (' ', '-', '_')).strip()&#10;        return safe_text.replace(' ', '_')&#10;    &#10;    @staticmethod&#10;    def get_safe_company_name(company_name: str) -&gt; str:&#10;        &quot;&quot;&quot;Convert company name to safe folder name&quot;&quot;&quot;&#10;        return &quot;&quot;.join(c for c in company_name if c.isalnum() or c in (' ', '-', '_')).strip().replace(' ', '_')&#10;    &#10;    @staticmethod&#10;    def detect_language(text: str) -&gt; str:&#10;        &quot;&quot;&quot;Detect if text is primarily French or English&quot;&quot;&quot;&#10;        french_indicators = [&#10;            'développement', 'stagiaire', 'entreprise', 'équipe', 'expérience',&#10;            'compétences', 'université', 'français', 'poste', 'candidat'&#10;        ]&#10;        &#10;        text_lower = text.lower()&#10;        french_count = sum(1 for indicator in french_indicators if indicator in text_lower)&#10;        &#10;        return 'french' if french_count &gt;= 2 else 'english'&#10;&#10;&#10;class CacheUtils:&#10;    &quot;&quot;&quot;Utility class for cache operations&quot;&quot;&quot;&#10;    &#10;    @staticmethod&#10;    def is_cache_fresh(cached_data: Dict, max_age_days: int = 730) -&gt; bool:&#10;        &quot;&quot;&quot;Check if cached data is fresh (less than max_age_days old)&quot;&quot;&quot;&#10;        if not cached_data or 'timestamp' not in cached_data:&#10;            return False&#10;        &#10;        try:&#10;            cached_time = datetime.fromisoformat(cached_data['timestamp'])&#10;            return datetime.now() - cached_time &lt; timedelta(days=max_age_days)&#10;        except (ValueError, KeyError):&#10;            return False&#10;    &#10;    @staticmethod&#10;    def create_cache_entry(data: Any) -&gt; Dict:&#10;        &quot;&quot;&quot;Create a cache entry with timestamp&quot;&quot;&quot;&#10;        return {&#10;            'timestamp': datetime.now().isoformat(),&#10;            'data': data&#10;        }&#10;&#10;&#10;class PathUtils:&#10;    &quot;&quot;&quot;Utility class for path operations&quot;&quot;&quot;&#10;    &#10;    @staticmethod&#10;    def ensure_dir(path: Path) -&gt; Path:&#10;        &quot;&quot;&quot;Create directory if it doesn't exist and return path&quot;&quot;&quot;&#10;        path.mkdir(parents=True, exist_ok=True)&#10;        return path&#10;    &#10;    @staticmethod&#10;    def file_exists(path: Path) -&gt; bool:&#10;        &quot;&quot;&quot;Check if file exists&quot;&quot;&quot;&#10;        return path.exists() and path.is_file()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/streamlined_cover_letter_generator.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/streamlined_cover_letter_generator.py" />
              <option name="updatedContent" value="from openai import AsyncOpenAI&#10;import json&#10;import time&#10;from datetime import datetime, timedelta&#10;from typing import Dict, List, Optional&#10;from dataclasses import dataclass&#10;from pathlib import Path&#10;import re&#10;from reportlab.lib.pagesizes import letter&#10;from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle&#10;from reportlab.lib.units import inch&#10;from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer&#10;from docx import Document&#10;from docx.enum.text import WD_ALIGN_PARAGRAPH&#10;from personal_context import PERSONAL_CONTEXT, PersonalContext&#10;from prompts_new import COMPANY_RESEARCH_PROMPT, COVER_LETTER_GENERATION_PROMPT_ENGLISH, COVER_LETTER_GENERATION_PROMPT_FRENCH&#10;from shared_utils import FileUtils, StringUtils, CacheUtils, PathUtils&#10;&#10;@dataclass&#10;class JobPosting:&#10;    company_name: str&#10;    job_title: str&#10;    job_description: str&#10;    job_id: str&#10;    link: Optional[str] = None&#10;&#10;class CoverLetterGenerator:&#10;    def __init__(self, openai_api_key: str, personal_context: PersonalContext, config_file=&quot;user_config.json&quot;):&#10;        self.client = AsyncOpenAI(api_key=openai_api_key)&#10;        self.personal_context = personal_context&#10;&#10;        # Load user configuration using shared utility&#10;        self.config = FileUtils.load_json(Path(config_file), {})&#10;&#10;        # Directory paths&#10;        self.job_contents_dir = Path(&quot;./job_contents&quot;)&#10;        self.company_research_cache = Path(&quot;./company_research_cache.json&quot;)&#10;&#10;        # Professional contact information from config&#10;        personal_info = self.config.get('personal_info', {})&#10;        self.contact_info = {&#10;            &quot;name&quot;: personal_info.get('name', 'Your Name'),&#10;            &quot;email&quot;: personal_info.get('email', 'your.email@example.com'),&#10;            &quot;phone&quot;: personal_info.get('phone', '(000) 000-0000'),&#10;            &quot;linkedin&quot;: personal_info.get('linkedin', 'linkedin.com/in/yourprofile')&#10;        }&#10;&#10;    def check_existing_cover_letter(self, company_name: str, job_id: str, job_title: str = None) -&gt; bool:&#10;        &quot;&quot;&quot;Check if a cover letter already exists for this job&quot;&quot;&quot;&#10;        company_folder = self.get_company_folder(company_name)&#10;        &#10;        # Check for position-specific files if job_title is provided&#10;        if job_title:&#10;            safe_title = StringUtils.get_safe_filename(job_title)&#10;            for ext in ['pdf', 'docx']:&#10;                if PathUtils.file_exists(company_folder / f&quot;{safe_title}_cover_letter.{ext}&quot;):&#10;                    return True&#10;&#10;        # Fallback: check for generic files (backward compatibility)&#10;        for ext in ['pdf', 'docx']:&#10;            if PathUtils.file_exists(company_folder / f&quot;cover_letter.{ext}&quot;):&#10;                return True&#10;                &#10;        return False&#10;&#10;    def get_company_folder(self, company_name: str) -&gt; Path:&#10;        &quot;&quot;&quot;Get the company folder path, create if it doesn't exist&quot;&quot;&quot;&#10;        safe_name = StringUtils.get_safe_company_name(company_name)&#10;        return PathUtils.ensure_dir(self.job_contents_dir / safe_name)&#10;&#10;    def save_job_description(self, company_folder: Path, job_posting: JobPosting):&#10;        &quot;&quot;&quot;Save job description to company folder&quot;&quot;&quot;&#10;        safe_title = StringUtils.get_safe_filename(job_posting.job_title)&#10;        job_desc_file = company_folder / f&quot;{safe_title}_job_description.md&quot;&#10;        &#10;        content = f&quot;&quot;&quot;# {job_posting.job_title}&#10;&#10;**Company:** {job_posting.company_name}&#10;**Job ID:** {job_posting.job_id}&#10;{f&quot;**Link:** {job_posting.link}&quot; if job_posting.link else &quot;&quot;}&#10;&#10;## Job Description&#10;&#10;{job_posting.job_description}&quot;&quot;&quot;&#10;        &#10;        FileUtils.save_text(job_desc_file, content)&#10;&#10;    def save_research_results(self, company_folder: Path, company_name: str, research_data: dict):&#10;        &quot;&quot;&quot;Save research results to company folder&quot;&quot;&quot;&#10;        research_file = company_folder / f&quot;Research_{StringUtils.get_safe_company_name(company_name)}.json&quot;&#10;        FileUtils.save_json(research_file, CacheUtils.create_cache_entry(research_data))&#10;&#10;    def load_company_research_cache(self) -&gt; Dict:&#10;        &quot;&quot;&quot;Load cached company research results&quot;&quot;&quot;&#10;        return FileUtils.load_json(self.company_research_cache, {})&#10;&#10;    def save_company_research_cache(self, cache: Dict):&#10;        &quot;&quot;&quot;Save company research results to cache&quot;&quot;&quot;&#10;        try:&#10;            print(f&quot; Saving company research cache to: {self.company_research_cache}&quot;)&#10;            FileUtils.save_json(self.company_research_cache, cache)&#10;            print(f&quot;✅ Successfully saved cache with {len(cache)} companies&quot;)&#10;        except Exception as e:&#10;            print(f&quot;❌ Error saving company research cache: {e}&quot;)&#10;            print(f&quot;   Cache path: {self.company_research_cache}&quot;)&#10;            print(f&quot;   Cache data keys: {list(cache.keys()) if cache else 'None'}&quot;)&#10;            raise&#10;&#10;    def is_research_fresh(self, cached_data: Dict) -&gt; bool:&#10;        &quot;&quot;&quot;Check if cached research is less than 2 years old&quot;&quot;&quot;&#10;        return CacheUtils.is_cache_fresh(cached_data, max_age_days=730)&#10;&#10;    def load_job_description(self, company_name: str, job_title: str, job_id: str) -&gt; Optional[str]:&#10;        &quot;&quot;&quot;Load job description from company folder&quot;&quot;&quot;&#10;        try:&#10;            company_folder = self.get_company_folder(company_name)&#10;            safe_title = StringUtils.get_safe_filename(job_title)&#10;            job_desc_file = company_folder / f&quot;{safe_title}_job_description.md&quot;&#10;&#10;            # Try multiple fallback locations for backward compatibility&#10;            fallback_files = [&#10;                company_folder / f&quot;Job_Description_{job_id}.md&quot;,&#10;                company_folder / &quot;job_description.md&quot;,&#10;                self.job_contents_dir / f&quot;{safe_title}_{job_id}.md&quot;&#10;            ]&#10;&#10;            if not PathUtils.file_exists(job_desc_file):&#10;                for fallback in fallback_files:&#10;                    if PathUtils.file_exists(fallback):&#10;                        job_desc_file = fallback&#10;                        break&#10;                else:&#10;                    print(f&quot;⚠️ Job description file not found for {company_name} - {job_title}&quot;)&#10;                    return None&#10;&#10;            with open(job_desc_file, 'r', encoding='utf-8') as f:&#10;                content = f.read()&#10;&#10;            # Extract job description content&#10;            description_match = re.search(r'## Job Description\s*\n\n(.*)', content, re.DOTALL)&#10;            if description_match:&#10;                return description_match.group(1).strip()&#10;&#10;            # Fallback: return content after the first few metadata lines&#10;            lines = content.split('\n')&#10;            for i, line in enumerate(lines):&#10;                if line.startswith('## Job Description') or (i &gt; 5 and line.strip()):&#10;                    return '\n'.join(lines[i+1:]).strip()&#10;            &#10;            return content.strip()&#10;&#10;        except Exception as e:&#10;            print(f&quot;❌ Error loading job description: {e}&quot;)&#10;            return None&#10;&#10;    def detect_language(self, text: str) -&gt; str:&#10;        &quot;&quot;&quot;Detect if text is primarily French or English&quot;&quot;&quot;&#10;        return StringUtils.detect_language(text)&#10;&#10;    # Continue with the rest of the methods from the original file...&#10;    # This is just the beginning of the streamlined version" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_cover_letter_generation.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_cover_letter_generation.py" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Test script for cover letter generation pipeline&#10;&quot;&quot;&quot;&#10;&#10;import asyncio&#10;import json&#10;import os&#10;from pathlib import Path&#10;&#10;async def test_single_cover_letter():&#10;    &quot;&quot;&quot;Test generating a single cover letter&quot;&quot;&quot;&#10;    print(&quot; Testing single cover letter generation...\n&quot;)&#10;    &#10;    try:&#10;        from cover_letter_generator import CoverLetterGenerator, JobPosting&#10;        from personal_context import PERSONAL_CONTEXT&#10;        &#10;        # Check API key&#10;        api_key = os.getenv(&quot;OPENAI_API_KEY&quot;)&#10;        if not api_key:&#10;            print(&quot;❌ OpenAI API key not found in environment&quot;)&#10;            return False&#10;        &#10;        print(f&quot;✅ API key found: {api_key[:20]}...&quot;)&#10;        &#10;        # Initialize generator&#10;        generator = CoverLetterGenerator(api_key, PERSONAL_CONTEXT)&#10;        print(&quot;✅ CoverLetterGenerator initialized&quot;)&#10;        &#10;        # Load a test job from your processed jobs&#10;        with open('processed_jobs.json', 'r') as f:&#10;            processed_jobs = json.load(f)&#10;        &#10;        # Get the first job as a test&#10;        job_id, job_info = next(iter(processed_jobs.items()))&#10;        print(f&quot; Testing with job: {job_info['job_title']} at {job_info['company']}&quot;)&#10;        &#10;        # Load job description from markdown file&#10;        job_description = generator.load_job_description(job_info[&quot;job_title&quot;], job_id)&#10;        &#10;        if not job_description:&#10;            print(&quot;❌ Could not load job description&quot;)&#10;            return False&#10;        &#10;        print(f&quot;✅ Job description loaded ({len(job_description)} characters)&quot;)&#10;        &#10;        # Create JobPosting object&#10;        job_posting = JobPosting(&#10;            company_name=job_info[&quot;company&quot;],&#10;            job_title=job_info[&quot;job_title&quot;],&#10;            job_description=job_description,&#10;            job_id=job_id,&#10;            link=job_info.get(&quot;link&quot;)&#10;        )&#10;        &#10;        print(&quot; Generating cover letter...&quot;)&#10;        &#10;        # Generate cover letter&#10;        result = await generator.generate_cover_letter(job_posting)&#10;        &#10;        if result[&quot;success&quot;]:&#10;            print(&quot;✅ Cover letter generated successfully!&quot;)&#10;            print(f&quot; Saved to: {result['filepath']}&quot;)&#10;            print(f&quot; Preview (first 200 chars):&quot;)&#10;            print(&quot;-&quot; * 50)&#10;            print(result['cover_letter'][:200] + &quot;...&quot;)&#10;            print(&quot;-&quot; * 50)&#10;            return True&#10;        else:&#10;            print(f&quot;❌ Cover letter generation failed: {result['error']}&quot;)&#10;            return False&#10;            &#10;    except Exception as e:&#10;        print(f&quot;❌ Test failed with error: {e}&quot;)&#10;        import traceback&#10;        traceback.print_exc()&#10;        return False&#10;&#10;async def test_job_loading():&#10;    &quot;&quot;&quot;Test loading jobs from the processed database&quot;&quot;&quot;&#10;    print(&quot;\n Testing job loading from database...\n&quot;)&#10;    &#10;    try:&#10;        from cover_letter_generator import CoverLetterGenerator&#10;        &#10;        # Load jobs using the class method&#10;        job_postings = CoverLetterGenerator.load_jobs_from_processed_file(&quot;processed_jobs.json&quot;)&#10;        &#10;        print(f&quot;✅ Loaded {len(job_postings)} job postings&quot;)&#10;        &#10;        # Show first few jobs&#10;        for i, job in enumerate(job_postings[:3]):&#10;            print(f&quot;   {i+1}. {job.job_title} at {job.company_name} (ID: {job.job_id})&quot;)&#10;            print(f&quot;      Description length: {len(job.job_description)} characters&quot;)&#10;        &#10;        if len(job_postings) &gt; 3:&#10;            print(f&quot;   ... and {len(job_postings) - 3} more jobs&quot;)&#10;        &#10;        return len(job_postings) &gt; 0&#10;        &#10;    except Exception as e:&#10;        print(f&quot;❌ Job loading test failed: {e}&quot;)&#10;        return False&#10;&#10;def check_prerequisites():&#10;    &quot;&quot;&quot;Check if all prerequisites are met&quot;&quot;&quot;&#10;    print(&quot; Checking prerequisites...\n&quot;)&#10;    &#10;    issues = []&#10;    &#10;    # Check files&#10;    required_files = ['processed_jobs.json', 'config.json', '.env']&#10;    for file in required_files:&#10;        if not os.path.exists(file):&#10;            issues.append(f&quot;Missing file: {file}&quot;)&#10;        else:&#10;            print(f&quot;✅ {file} found&quot;)&#10;    &#10;    # Check directories&#10;    if not os.path.exists('job_contents'):&#10;        issues.append(&quot;Missing job_contents directory&quot;)&#10;    else:&#10;        job_files = list(Path('job_contents').glob('*.md'))&#10;        print(f&quot;✅ job_contents directory found with {len(job_files)} job descriptions&quot;)&#10;    &#10;    # Check API key&#10;    api_key = os.getenv('OPENAI_API_KEY')&#10;    if not api_key:&#10;        # Try loading from .env&#10;        if os.path.exists('.env'):&#10;            with open('.env', 'r') as f:&#10;                for line in f:&#10;                    if line.startswith('OPENAI_API_KEY='):&#10;                        api_key = line.split('=', 1)[1].strip()&#10;                        os.environ['OPENAI_API_KEY'] = api_key&#10;                        print(&quot;✅ API key loaded from .env file&quot;)&#10;                        break&#10;        &#10;        if not api_key:&#10;            issues.append(&quot;OPENAI_API_KEY not set in environment or .env file&quot;)&#10;    else:&#10;        print(&quot;✅ OpenAI API key found&quot;)&#10;    &#10;    if issues:&#10;        print(f&quot;\n❌ Found {len(issues)} issues:&quot;)&#10;        for issue in issues:&#10;            print(f&quot;   - {issue}&quot;)&#10;        return False&#10;    else:&#10;        print(&quot;\n✅ All prerequisites met!&quot;)&#10;        return True&#10;&#10;async def main():&#10;    print(&quot;=== Cover Letter Generation Pipeline Test ===\n&quot;)&#10;    &#10;    # Check prerequisites&#10;    if not check_prerequisites():&#10;        print(&quot;\n❌ Prerequisites not met. Please fix the issues above first.&quot;)&#10;        return&#10;    &#10;    # Test job loading&#10;    if not await test_job_loading():&#10;        print(&quot;\n❌ Job loading failed. Cannot proceed with cover letter test.&quot;)&#10;        return&#10;    &#10;    # Test single cover letter generation&#10;    success = await test_single_cover_letter()&#10;    &#10;    if success:&#10;        print(&quot;\n All tests passed! Your pipeline is ready to use.&quot;)&#10;        print(&quot;\nTo generate cover letters for multiple jobs:&quot;)&#10;        print(&quot;python3 run_cover_letter_generation.py&quot;)&#10;    else:&#10;        print(&quot;\n❌ Tests failed. Please check the errors above.&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    asyncio.run(main())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_improved_generator.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_improved_generator.py" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Test the improved cover letter generator&#10;&quot;&quot;&quot;&#10;&#10;import asyncio&#10;import os&#10;from cover_letter_generator_v2 import CoverLetterGenerator&#10;from personal_context import PERSONAL_CONTEXT&#10;&#10;async def test_improved_generator():&#10;    &quot;&quot;&quot;Test the improved cover letter generator on the same Arup job&quot;&quot;&quot;&#10;    &#10;    # Set up API key&#10;    api_key = os.getenv(&quot;OPENAI_API_KEY&quot;)&#10;    if not api_key:&#10;        # Load from .env file&#10;        if os.path.exists('.env'):&#10;            with open('.env', 'r') as f:&#10;                for line in f:&#10;                    if line.startswith('OPENAI_API_KEY='):&#10;                        api_key = line.split('=', 1)[1].strip()&#10;                        os.environ['OPENAI_API_KEY'] = api_key&#10;                        break&#10;    &#10;    if not api_key:&#10;        print(&quot;❌ API key not found&quot;)&#10;        return&#10;    &#10;    # Initialize improved generator&#10;    generator = CoverLetterGenerator(api_key, PERSONAL_CONTEXT)&#10;    &#10;    # Load the same Arup job for comparison&#10;    job_postings = CoverLetterGenerator.load_jobs_from_processed_file(&quot;processed_jobs.json&quot;)&#10;    arup_job = next((job for job in job_postings if job.company_name == &quot;Arup&quot;), None)&#10;    &#10;    if not arup_job:&#10;        print(&quot;❌ Arup job not found&quot;)&#10;        return&#10;    &#10;    print(&quot; Generating improved cover letter for Arup...&quot;)&#10;    print(&quot; This will be saved as *_v2.txt so you can compare with the original&quot;)&#10;    &#10;    # Generate new cover letter&#10;    result = await generator.generate_cover_letter(arup_job)&#10;    &#10;    if result[&quot;success&quot;]:&#10;        print(f&quot;✅ Improved cover letter generated!&quot;)&#10;        print(f&quot; Saved to: {result['filepath']}&quot;)&#10;        print(f&quot;\n Preview:&quot;)&#10;        print(&quot;-&quot; * 50)&#10;        print(result['cover_letter'][:400] + &quot;...&quot;)&#10;        print(&quot;-&quot; * 50)&#10;        print(&quot;\n Key improvements:&quot;)&#10;        print(&quot;   - No job ID mention&quot;)&#10;        print(&quot;   - More conversational tone&quot;)&#10;        print(&quot;   - Banned corporate buzzwords&quot;)&#10;        print(&quot;   - Ends with 'Andres Gonzalez'&quot;)&#10;        print(&quot;   - Better paragraph flow&quot;)&#10;    else:&#10;        print(f&quot;❌ Generation failed: {result['error']}&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    asyncio.run(test_improved_generator())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_killer_generator.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_killer_generator.py" />
              <option name="originalContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Test the killer cover letter generator with professional formatting&#10;&quot;&quot;&quot;&#10;&#10;import asyncio&#10;import os&#10;from cover_letter_generator_killer import CoverLetterGenerator&#10;from personal_context import PERSONAL_CONTEXT&#10;&#10;async def test_killer_generator():&#10;    &quot;&quot;&quot;Test the killer cover letter generator on Arup job&quot;&quot;&quot;&#10;&#10;    # Set up API key&#10;    api_key = os.getenv(&quot;OPENAI_API_KEY&quot;)&#10;    if not api_key:&#10;        # Load from .env file&#10;        if os.path.exists('.env'):&#10;            with open('.env', 'r') as f:&#10;                for line in f:&#10;                    if line.startswith('OPENAI_API_KEY='):&#10;                        api_key = line.split('=', 1)[1].strip()&#10;                        os.environ['OPENAI_API_KEY'] = api_key&#10;                        break&#10;&#10;    if not api_key:&#10;        print(&quot;❌ API key not found&quot;)&#10;        return&#10;&#10;    # Initialize killer generator&#10;    generator = CoverLetterGenerator(api_key, PERSONAL_CONTEXT)&#10;&#10;    # Load jobs&#10;    job_postings = CoverLetterGenerator.load_jobs_from_processed_file(&quot;processed_jobs.json&quot;)&#10;    arup_job = next((job for job in job_postings if job.company_name == &quot;Arup&quot;), None)&#10;&#10;    if not arup_job:&#10;        print(&quot;❌ Arup job not found, using first available job&quot;)&#10;        arup_job = job_postings[0] if job_postings else None&#10;&#10;    if not arup_job:&#10;        print(&quot;❌ No jobs found&quot;)&#10;        return&#10;&#10;    print(f&quot; Generating KILLER cover letter for: {arup_job.job_title} at {arup_job.company_name}&quot;)&#10;    print(&quot; This will generate PDF, Word, and Text versions with professional formatting&quot;)&#10;&#10;    # Generate killer cover letter&#10;    result = await generator.generate_cover_letter(arup_job)&#10;&#10;    if result[&quot;success&quot;]:&#10;        print(f&quot;\n KILLER cover letter generated successfully!&quot;)&#10;        print(f&quot; Files created:&quot;)&#10;        print(f&quot;    PDF: {result['pdf_filepath']}&quot;)&#10;        print(f&quot;    Word: {result['docx_filepath']}&quot;)&#10;        print(f&quot;    Text: {result['txt_filepath']}&quot;)&#10;&#10;        print(f&quot;\n Preview:&quot;)&#10;        print(&quot;-&quot; * 50)&#10;        print(result['cover_letter'][:300] + &quot;...&quot;)&#10;        print(&quot;-&quot; * 50)&#10;&#10;        print(&quot;\n✨ Key improvements:&quot;)&#10;        print(&quot;   - Professional PDF and Word formatting&quot;)&#10;        print(&quot;   - Contact header with your info&quot;)&#10;        print(&quot;   - Killer 5-part structure&quot;)&#10;        print(&quot;   - Marketing-focused approach&quot;)&#10;        print(&quot;   - Company-specific research&quot;)&#10;        print(&quot;   - Quantified achievements&quot;)&#10;        print(&quot;   - No corporate buzzwords&quot;)&#10;&#10;    else:&#10;        print(f&quot;❌ Generation failed: {result['error']}&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    asyncio.run(test_killer_generator())&#10;" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Test the killer cover letter generator with professional formatting&#10;&quot;&quot;&quot;&#10;&#10;import asyncio&#10;import os&#10;from cover_letter_generator_killer import CoverLetterGenerator&#10;from personal_context import PERSONAL_CONTEXT&#10;&#10;async def test_killer_generator():&#10;    &quot;&quot;&quot;Test the killer cover letter generator on Arup job&quot;&quot;&quot;&#10;&#10;    # Set up API key&#10;    api_key = os.getenv(&quot;OPENAI_API_KEY&quot;)&#10;    if not api_key:&#10;        # Load from .env file&#10;        if os.path.exists('.env'):&#10;            with open('.env', 'r') as f:&#10;                for line in f:&#10;                    if line.startswith('OPENAI_API_KEY='):&#10;                        api_key = line.split('=', 1)[1].strip()&#10;                        os.environ['OPENAI_API_KEY'] = api_key&#10;                        break&#10;&#10;    if not api_key:&#10;        print(&quot;❌ API key not found&quot;)&#10;        return&#10;&#10;    # Initialize killer generator&#10;    generator = CoverLetterGenerator(api_key, PERSONAL_CONTEXT)&#10;&#10;    # Load jobs&#10;    job_postings = CoverLetterGenerator.load_jobs_from_processed_file(&quot;processed_jobs.json&quot;)&#10;    arup_job = next((job for job in job_postings if job.company_name == &quot;Arup&quot;), None)&#10;&#10;    if not arup_job:&#10;        print(&quot;❌ Arup job not found, using first available job&quot;)&#10;        arup_job = job_postings[0] if job_postings else None&#10;&#10;    if not arup_job:&#10;        print(&quot;❌ No jobs found&quot;)&#10;        return&#10;&#10;    print(f&quot; Generating KILLER cover letter for: {arup_job.job_title} at {arup_job.company_name}&quot;)&#10;    print(&quot; This will generate PDF, Word, and Text versions with professional formatting&quot;)&#10;&#10;    # Generate killer cover letter&#10;    result = await generator.generate_cover_letter(arup_job)&#10;&#10;    if result[&quot;success&quot;]:&#10;        print(f&quot;\n KILLER cover letter generated successfully!&quot;)&#10;        print(f&quot; Company folder: {result['company_folder']}&quot;)&#10;        print(f&quot; Files created:&quot;)&#10;        print(f&quot;    PDF: {result['pdf_filepath']}&quot;)&#10;        print(f&quot;    Word: {result['docx_filepath']}&quot;)&#10;        &#10;        # Show the new organized structure&#10;        print(f&quot;\n New organized structure created:&quot;)&#10;        print(f&quot;    {result['company_folder']}/&quot;)&#10;        print(f&quot;      job_description.md&quot;)&#10;        print(f&quot;      company_research.json&quot;)&#10;        print(f&quot;      cover_letter.pdf&quot;) &#10;        print(f&quot;      cover_letter.docx&quot;)&#10;&#10;        print(f&quot;\n Preview:&quot;)&#10;        print(&quot;-&quot; * 50)&#10;        print(result['cover_letter'][:300] + &quot;...&quot;)&#10;        print(&quot;-&quot; * 50)&#10;&#10;        print(&quot;\n✨ Key improvements:&quot;)&#10;        print(&quot;   - Professional PDF and Word formatting with underlined links&quot;)&#10;        print(&quot;   - Contact header with your info&quot;)&#10;        print(&quot;   - Killer 5-part structure&quot;)&#10;        print(&quot;   - Marketing-focused approach&quot;)&#10;        print(&quot;   - Company-specific research (cached to save tokens!)&quot;)&#10;        print(&quot;   - Quantified achievements from your personal context&quot;)&#10;        print(&quot;   - No corporate buzzwords&quot;)&#10;        print(&quot;   - Organized company folders for easy management&quot;)&#10;&#10;    else:&#10;        print(f&quot;❌ Generation failed: {result['error']}&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    asyncio.run(test_killer_generator())" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>